\newcommand{\base}{\ensuremath{\mathsf{base}}\xspace}
\newcommand{\lloop}{\ensuremath{\mathsf{loop}}\xspace}
\newcommand{\seg}{\ensuremath{\mathsf{seg}}\xspace}
\newcommand{\eqtopath}{\ensuremath{\mathsf{eqtopath}}\xspace}

\chapter{Higher inductive types}
\label{cha:hits}

Like inductive types, the notion of \emph{higher inductive type} is a general
schema for defining new types generated by some constructors. With inductive
types, the return type of every constructor was required to be the inductive
type we are defining but now we will relax this condition by allowing the return
type of a constructor to be an identity type in the higher inductive type that
we’re defining.

For instance we can consider the following higher inductive type:

\begin{align*}
  \Sn^1 \defeq&\ |\ \base:\Sn^1 \\
  &\ |\ \lloop:\id[\Sn^1]\base\base
\end{align*}

The intuition is that $\Sn^1$ is the type generated by a point \base and a path
\lloop from \base to itself.

If $P$ is a dependent type over $\Sn^1$ and we have a point $x:P(\base)$ and a
path $p:x=^P_\lloop{}x$ in $P$ over $\lloop$, then we can define a function
\[\Sn^1\mathsf{rec}_P(x,p):\prd{x:\Sn^1}P(x)\]
by
\begin{align*}
  \Sn^1\mathsf{rec}_P(x,p)(\base)&=x \\
  \map{(\Sn^1\mathsf{rec}_P(x,p))}{\lloop}&=p
  % This should be a \mapdep but I don’t see why we need different notations
\end{align*}

As with inductive types we can prove a nondependent elimination rule and an
$\eta$-rule.

\begin{lem}
  If $A$ is a type together with $x:A$ and $p:\id[A]xx$, then there is a
  function
  \[\Sn^1\mathsf{rec}^{\mathsf{nondep}}_A(x,p):\Sn^1\to{}A\]
  defined by
  \begin{align*}
    \Sn^1\mathsf{rec}^{\mathsf{nondep}}_A(x,p)(\base)&=x \\
    \map{(\Sn^1\mathsf{rec}^{\mathsf{nondep}}_A(x,p))}{\lloop}&=p
    % This one is a \map
  \end{align*}
\end{lem}

\begin{proof}
  This is the dependent elimination rule applied to the nondependent type
  $P(x)=A$. Note that the two types $x=^{\lambda{}x.A}_\lloop{}x$ and $x=_Ax$
  are the same.
\end{proof}

\begin{lem}
  If $A$ is a type and $f,g:\Sn^1\to{}A$ are two maps together with two
  equalities $p,q$:
  \[p:f(\base)=_Ag(\base)\]
  \[q:\map{f}\lloop=^{\lambda{}x.\,x=_Ax}_p\map{g}\lloop\]

  Then for all $x:\Sn^1$ we have $f(x)=g(x)$.
\end{lem}

\begin{proof}
  This is the dependent elimination rule for the dependent type
  $P(x)\defeq(f(x)=g(x))$.
\end{proof}

\section{The interval}
\label{sec:interval}

Let’s now define the interval type and prove a few properties about it. The
definition is the following:

\begin{align*}
  I \defeq&\ |\ 0:I\\
  &\ |\ 1:I \\
  &\ |\ \seg:\id[I]01
\end{align*}

The interval consist of two points $0$ and $1$ together with a path between the
two. From the point of view of homotopy theory, the interval is not really
interesting because it is contractible:

\begin{lem}
  The type $I$ is contractible.
\end{lem}

\begin{proof}
  We will prove that for all $x:I$ we have $x=_I1$. In other words we want a
  function $f$ of type $\prd{x:I}(x=_I1)$. We define $f$ in the following way:
  \begin{align*}
    f(0)&=\seg:0=_I1\\
    f(1)&=\refl{I}1:1=_I1\\
    \map{f}\seg&=\_:\seg=_\seg^{\lambda{}x.x=_I1}\refl{I}1
  \end{align*}

  The type of $\map{f}\seg$ is equivalent to $\trans\seg\seg=_{1=_I1}\refl{I}1$
  which is himself equivalent to $\rev\seg\ct\seg=\refl{I}1$ and there is a
  canonical term of that type.
\end{proof}

Using the interval type, we can easily prove function extensionality:

\begin{lem}
  If $f,g:A\to{}B$ are two functions such that $f(x)=g(x)$ for every $x:A$, then
  $f=g$ in the type $A\to{}B$.
\end{lem}

\begin{proof}
  Let’s call $p:\prd{x:A}(f(x)=g(x))$ the proof we have. For all $x:A$ we define
  a function $\widetilde{p}_x:I\to{}B$ by
  \begin{align*}
    \widetilde{p}_x(0) &= f(x) \\
    \widetilde{p}_x(1) &= g(x) \\
    \map{(\widetilde{p}_x)}\seg &= p(x)
  \end{align*}
  We now define $q:I\to(A\to{}B)$ by
  \[q(i)\defeq(\lambda{}x.\,\widetilde{p}_x(i))\]

  The image of $0$ by $q$ is the function $\lambda{}x.\,\widetilde{p}_x(0)$
  which is equal to $f$ because $\widetilde{p}_x(0)$ is defined by $f(x)$.

  In the same way we have $q(1)=g$ hence we have
  \[\map{q}\seg:f=_{(A\to{}B)}g\]
\end{proof}

\section{The flattening lemma}
\label{sec:flattening}

The flattening lemma is a general lemma about higher inductive types which says
that if $W$ is a higher inductive type and $P:W\to\type$ is a function defined
by induction and with the univalence axiom for the paths, then the total space
of $P$ is equivalent to a “flattened“ higher inductive type build up from $W$
and $P$.

In what follows, we will assume that we have $A,B:\type$ and $f,g:B\to{}A$ and
that the higher inductive type $W$ is of the form

\newcommand{\cc}{\mathsf{c}}
\newcommand{\pp}{\mathsf{p}}
\newcommand{\cct}{\widetilde{\mathsf{c}}}
\newcommand{\ppt}{\widetilde{\mathsf{p}}}

\begin{align*}
  W \defeq&\ |\ \cc:A\to{}W\\
  &\ |\ \pp:\prd{b:B}\cc(f(b))=_W\cc(g(b))
\end{align*}

Using binary sums and dependent sums a lot of interesting nonrecursive higher
inductive types can be represented in this form. All point constructors have to
be bundled in the type $A$ and all path constructors in the type $B$.

\begin{lem}[Flattening lemma]
  If $C:A\to\type$ is a family of types over $A$ and
  $D:\prd{b:B}C(f(b))\simeq{}C(g(b))$ is a family of equivalences over $B$, we
  can define a function
  \begin{align*}
    P &: W\to\type\\
    P(\cc(a)) &= C(a)\\
    \map{P}{\pp(b)} &= \eqtopath(D(b))
  \end{align*}

  We define another higher inductive type:
  \begin{align*}
    \widetilde{W} \defeq&\ |\ \cct:\prd{a:A}{x:C(a)}\widetilde{W}\\
    &\ |\
    \ppt:\prd{b:B}{x:C(f(b))}\cct(f(b),x)=_{\widetilde{W}}\cct(g(b),D(b)(x))
  \end{align*}

  The statement of the flattening lemma is that the total space of $P$ is
  equivalent to $\widetilde{W}$.
\end{lem}

\begin{proof}
  We will define two maps going back and forth and prove that they are inverse
  to each other.

  The map $f:\widetilde{W}\to\Sigma_{x:W}P(x)$ is defined by
  \begin{align*}
    f(\cct(a,x)) &= (\cc(a),x) \\
    \map{f}{\ppt(b,y)} &= (\pp(b),\map{(\lambda{}f.\,f\,x)}{\eqtopath(D(b))}
  \end{align*}

  For the inverse map $g:\Sigma_{x:W}P(x)\to\widetilde{W}$ we currify and define
  for all $x:W$ a map $\widetilde{g}_x:P(x)\to\widetilde{W}$ by induction on
  $x$.

  \emph{unfinished}
  % \begin{align*}
  %   \widetilde{g}_{\cc(a)} &= \lambda{}x^{C(a)}.\,\cct(a,x) \\
  %   \map{(\lambda{}x^W.\,\widetilde{g}_x)}{\pp(b)} &= 
  % \end{align*}
\end{proof}


% Local Variables:
% TeX-master: "main"
% End:
