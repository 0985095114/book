%%%% MACROS FOR NOTATION %%%%
% Use these for any notation where there are multiple options.

%%% Definitional equality (used infix) %%%
\newcommand{\jdeq}{\equiv}      % An equality judgment
\let\judgeq\jdeq
%\newcommand{\defeq}{\coloneqq}  % An equality currently being defined

\newcommand{\defeq}{\vcentcolon\equiv}  % An equality currently being defined



%%% Dependent products %%%
%% Call the macro like \prd{x,y:A}{p:x=y} with any number of
%% arguments.  Make sure that whatever comes *after* the call doesn't
%% begin with an open-brace, or it will be parsed as another argument.
\makeatletter
%% This version does {\textstyle\prod}(x,y:A)(p:x=y),
% \def\prd{{\textstyle\prod}\@prd}
% \def\@prd#1{(#1)\@ifnextchar\bgroup{\@prd}{,}}
%% This version does {\textstyle\prod}(x,y:A)\;{\textstyle\prod}(p:x=y),
\def\prd#1{{\textstyle\prod}(#1)\@ifnextchar\bgroup{\;\prd}{,\ }}
%% This version does ({\textstyle\prod}x,y:A)\;({\textstyle\prod}p:x=y),
%\def\prd#1{\big({\textstyle\prod} #1\big)\@ifnextchar\bgroup{\;\prd}{,}}
%% This version does \prod_{(x,y:A)} \prod_{(p:x=y)}
% \def\prd#1{\prod_{(#1)}\@ifnextchar\bgroup{\prd}{}}
%% This version does {\textstyle\prod}_{(x,y:A)} {\textstyle\prod}_{(p:x=y)}
% \def\prd#1{{\textstyle\prod}_{(#1)}\@ifnextchar\bgroup{\prd}{}}
%% This one is Agda style
% \def\prd#1{(#1)\to\@ifnextchar\bgroup{\prd}{}}

%%% Dependent products written with \forall, in the same style
\def\fall#1{{\forall}(#1)\@ifnextchar\bgroup{\;\fall}{,\ }}

%%% Dependent sums %%%
\def\sm#1{{\textstyle\sum}(#1)\@ifnextchar\bgroup{\;\sm}{,\ }}
\makeatother
\let\setof\Set    % from package 'braket', write \setof{ x:A | P(x) }.
\newcommand{\pair}{\ensuremath{\mathsf{pair}}\xspace}

%%% Identity types %%%
\newcommand{\id}[3][]{\ensuremath{#2 =_{#1} #3}\xspace}
\newcommand{\idtype}[3][]{\ensuremath{\mathsf{Id}_{#1}(#2,#3)}\xspace}

%%% Reflexivity terms %%%
\newcommand{\refl}[1]{\ensuremath{\mathsf{refl}_{#1}}\xspace}

%%% Path concatenation (used infix, in diagrammatic order) %%%
\newcommand{\ct}{\mathrel{\raisebox{.5ex}{$\centerdot$}}}

%%% Path reversal %%%
\newcommand{\opp}[1]{\mathord{{#1}^{-1}}}
\let\rev\opp

%%% Transport (covariant) %%%
\newcommand{\trans}[2]{\ensuremath{{#1}_{*}\left({#2}\right)}\xspace}
\newcommand{\transf}[1]{\ensuremath{{#1}_{*}}\xspace} % Without argument
\newcommand{\transport}[2]{\ensuremath{\mathsf{transport}_{*} \: {#2}\xspace}}
\newcommand{\transfib}[3]{\ensuremath{\mathsf{transport}^{#1}(#2,#3)\xspace}}
\newcommand{\transfibf}[1]{\ensuremath{\mathsf{transport}^{#1}\xspace}}

%%% Constant transport
\newcommand{\transconst}[3]{\ensuremath{\mathsf{transportconst}}^{#1}_{#2}(#3)\xspace}
\newcommand{\transconstf}{\ensuremath{\mathsf{transportconst}}\xspace}

%%% Map on paths %%%
\newcommand{\mapfunc}[1]{\ensuremath{\mathsf{ap}_{#1}}\xspace} % Without argument
\newcommand{\map}[2]{\ensuremath{{#1}\left({#2}\right)}\xspace}
\newcommand{\mapdepfunc}[1]{\ensuremath{\mathsf{apd}_{#1}}\xspace} % Without argument
\newcommand{\mapdep}[2]{\ensuremath{{#1}\llparenthesis{#2}\rrparenthesis}\xspace}
\let\apfunc\mapfunc
\let\ap\map
\let\apdfunc\mapdepfunc
\let\apd\mapdep

%%% Identity functions %%%
\newcommand{\idfunc}[1][]{\ensuremath{\mathsf{id}_{#1}}\xspace}

%%% Homotopies (written infix) %%%
\newcommand{\htpy}{\sim}

%%% Equivalence types %%%
\newcommand{\eqv}[2]{\ensuremath{#1 \simeq #2}\xspace}
\newcommand{\eqvspaced}[2]{\ensuremath{#1 \;\simeq\; #2}\xspace}
\newcommand{\isequiv}{\ensuremath{\mathsf{isequiv}}}
\newcommand{\qinv}{\ensuremath{\mathsf{qinv}}}
\newcommand{\ishae}{\ensuremath{\mathsf{ishae}}}
\newcommand{\linv}{\ensuremath{\mathsf{linv}}}
\newcommand{\rinv}{\ensuremath{\mathsf{rinv}}}
\newcommand{\biinv}{\ensuremath{\mathsf{biinv}}}

%%% Universe types %%%
%\newcommand{\type}{\ensuremath{\mathsf{Type}}\xspace}
\newcommand{\UU}{\ensuremath{\mathcal{U}}\xspace}
\let\bbU\UU
\let\type\UU
% Universes of truncated types
\newcommand{\typele}[1]{\ensuremath{{#1}\text-\mathsf{Type}}\xspace}
\newcommand{\typeleU}[1]{\ensuremath{{#1}\text-\mathsf{Type}_\UU}\xspace}
\newcommand{\typelep}[1]{\ensuremath{{(#1)}\text-\mathsf{Type}}\xspace}
\newcommand{\typelepU}[1]{\ensuremath{{(#1)}\text-\mathsf{Type}_\UU}\xspace}
\let\ntype\typele
\let\ntypeU\typeleU
\let\ntypep\typelep
\let\ntypepU\typelepU
\renewcommand{\set}{\ensuremath{\mathsf{Set}}\xspace}
\newcommand{\setU}{\ensuremath{\mathsf{Set}_\UU}\xspace}
\newcommand{\prop}{\ensuremath{\mathsf{Prop}}\xspace}
\newcommand{\propU}{\ensuremath{\mathsf{Prop}_\UU}\xspace}

%%% Truncation levels
\newcommand{\iscontr}{\ensuremath{\mathsf{isContr}}}
\newcommand{\isset}{\ensuremath{\mathsf{isSet}}}
\newcommand{\isprop}{\ensuremath{\mathsf{isProp}}}

%%% Projections out of dependent sums %%%
\newcommand{\proj}[1]{\ensuremath{\mathsf{pr}_{#1}}\xspace}

%%% Homotopy fibers %%%
\newcommand{\hfiber}[2]{\ensuremath{\mathsf{hFiber}(#1,#2)}\xspace}

%%% Bracket/squash/truncation types %%%
% \newcommand{\brck}[1]{\textsf{mere}(#1)}
% \newcommand{\Brck}[1]{\textsf{mere}\Big(#1\Big)}
% \newcommand{\trunc}[2]{\tau_{#1}(#2)}
% \newcommand{\Trunc}[2]{\tau_{#1}\Big(#2\Big)}
% \newcommand{\truncf}[1]{\tau_{#1}}
\newcommand{\trunc}[2]{\Vert #2\Vert_{#1}}
\newcommand{\Trunc}[2]{\Big\Vert #2\Big\Vert_{#1}}
\newcommand{\truncf}[1]{\Vert -\Vert_{#1}}
\newcommand{\tproj}[2]{|#2|_{#1}}
\newcommand{\tprojf}[1]{|-|_{#1}}
\def\pizero{\trunc0}
%\newcommand{\brck}[1]{\trunc{-1}{#1}}
%\newcommand{\Brck}[1]{\Trunc{-1}{#1}}
%\newcommand{\bproj}[1]{\tproj{-1}{#1}}
%\newcommand{\bprojf}{\tprojf{-1}}

\newcommand{\brck}[1]{\trunc{}{#1}}
\newcommand{\Brck}[1]{\Trunc{}{#1}}
\newcommand{\bproj}[1]{\tproj{}{#1}}
\newcommand{\bprojf}{\tprojf{}}


%
%%% The empty type
\newcommand{\emptyt}{\ensuremath{\mathbf{0}}\xspace}

%%% The unit type
\newcommand{\unit}{\ensuremath{\mathbf{1}}\xspace}
\newcommand{\ttt}{\ensuremath{\star}\xspace}

%%% The two-element type
\newcommand{\bool}{\ensuremath{\mathbf{2}}\xspace}

%%% Injections into binary sums
\newcommand{\inl}{\ensuremath{\mathsf{inl}}\xspace}
\newcommand{\inr}{\ensuremath{\mathsf{inr}}\xspace}

%%% Blanks (i.e. anonymous lambdas)
\newcommand{\blank}{\mathord{\underline{\hspace{1ex}}}}
%\newcommand{\blank}{(-)}
%\newcommand{\blank}{(?)}

%%% Some decorations
%\newcommand{\bbU}{\ensuremath{\mathbb{U}}\xspace}
\newcommand{\bbB}{\ensuremath{\mathbb{B}}\xspace}
\newcommand{\bbP}{\ensuremath{\mathbb{P}}\xspace}

%%% Some categories
\newcommand{\uset}{\ensuremath{\underline{\set}}\xspace}
\newcommand{\ucat}{\ensuremath{\underline{\mathsf{Cat}}}\xspace}
\newcommand{\urel}{\ensuremath{\underline{\mathsf{Rel}}}\xspace}
\newcommand{\uhilb}{\ensuremath{\underline{\mathsf{Hilb}}}\xspace}

%%% Spheres
\newcommand{\Sn}{\mathbb{S}}

%%% Natural numbers
\newcommand{\N}{\ensuremath{\mathbb{N}}\xspace}
%\newcommand{\N}{{\bf N}}
\let\nat\N
\let\Nat\N
\newcommand{\suc}{\mathsf{succ}}
\newcommand{\rec}{\mathsf{succ}}

%%% Function extensionality
\newcommand{\funext}{\mathsf{funext}}
\newcommand{\happly}{\mathsf{happly}}

%%% A naturality lemma
\newcommand{\com}[3]{\mathtt{swap}_{#1,#2}(#3)}


%%%% THEOREM ENVIRONMENTS %%%%

% Hyperref includes the command \autoref{...} which is like \ref{...}
% except that it automatically inserts the type of the thing you're
% referring to, e.g. it produces "Theorem 3.8" instead of just "3.8"
% (and makes the whole thing a hyperlink).  This saves a slight amount
% of typing, but more importantly it means that if you decide later on
% that 3.8 should be a Lemma or a Definition instead of a Theorem, you
% don't have to change the name in all the places you referred to it.

% The following hack improves on this by using the same counter for
% all theorem-type environments, so that after Theorem 1.1 comes
% Corollary 1.2 rather than Corollary 1.1.  This makes it much easier
% for the reader to find a particular theorem when flipping through
% the document.
\makeatletter
\def\defthm#1#2{%
  %% All types of theorems are numbered inside sections
  \newtheorem{#1}{#2}[section]%
  %% This command tells hyperref's \autoref what to call things
  \expandafter\def\csname #1autorefname\endcsname{#2}%
  %% This makes all the theorem counters secretly the same counter
  \expandafter\let\csname c@#1\endcsname\c@thm}

% Now define a bunch of theorem-type environments.
\newtheorem{thm}{Theorem}[section]
\newcommand{\thmautorefname}{Theorem}
%\defthm{prop}{Proposition}   % Probably we shouldn't use "Proposition" in this way
\defthm{cor}{Corollary}
\defthm{lem}{Lemma}
\defthm{axiom}{Axiom}
% Since definitions and theorems in type theory are synonymous, should
% we actually use the same theoremstyle for them?
\theoremstyle{definition}
\defthm{defn}{Definition}
\theoremstyle{remark}
\defthm{rmk}{Remark}
\defthm{eg}{Example}
\defthm{egs}{Examples}
\defthm{notes}{Notes}
% Number exercises within chapters, with their own counter.
\newtheorem{ex}{Exercise}[chapter]
\def\exautorefname{Exercise}


%%%% EQUATION NUMBERING %%%%

% The following hack uses the single theorem counter to number
% equations as well, so that we don't have both Theorem 1.1 and
% equation (1.1).
\let\c@equation\c@thm
\numberwithin{equation}{section}


%%%% ENUMERATE NUMBERING %%%%

% Number the first level of enumerates as (i), (ii), ...
\renewcommand{\theenumi}{(\roman{enumi})}
\renewcommand{\labelenumi}{\theenumi}


%%%% MARGINS %%%%

% This is a matter of personal preference, but I think the left
% margins on enumerates and itemizes are too wide.
\setitemize[1]{leftmargin=2em}
\setenumerate[1]{leftmargin=*}

% Likewise that they are too spaced out.
\setitemize[1]{itemsep=-0.2em}
\setenumerate[1]{itemsep=-0.2em}

%%%% CITATIONS %%%%

\renewcommand{\cite}[1]{\citep{#1}}

\input{pa-macros}


% Local Variables:
% mode: latex
% TeX-master: "main"
% End:
