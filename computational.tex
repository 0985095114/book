\newcommand\ua[1]{\ensuremath{\mathsf{ua}} \: #1}

\section{The identity structure of specific types}
\label{sec:computational}

In Chapter~\ref{cha:introduction} we introduced many ways to form new types: cartesian products, disjoint unions, dependent products, dependent sums, etc.
In the previous sections of this chapter, we have seen that \emph{all} types in homotopy type theory behave like spaces or higher groupoids.
Our goal in this section is to make explicit how this higher structure behaves, for particular types defined as in Chapter~\ref{cha:typetheory}.

It turns out that for many types $A$, the equality types $\id[A]xy$ can be characterized, up to equivalence, in terms of whatever data was used to construct $A$.
For instance, if $A$ is a cartesian product $B\times C$, and $x\jdeq (b,c)$ and $y\jdeq(b',c')$, then we have an equivalence
\begin{equation}\label{eq:prodeqv}
  \eqv{\Big((b,c)=(b',c')\Big)}{\Big((b=b')\times (c=c')\Big)}.
\end{equation}
In more traditional language, two ordered pairs are equal just when their components are equal (but the equivalence~\eqref{eq:prodeqv} says rather more than this).
The higher structure of the identity types can also be expressed in terms of these equivalences; for instance, concatenating two equalities between pairs corresponds to pairwise concatenation.

Similarly, when a dependent type $P:A\to\type$ is built up fiberwise using the type forming rules from Chapter~\ref{cha:typetheory}, the operation $\transfib{P}{p}{-}$ can be characterized, up to homotopy, in terms of the corresponding operations on the data that went into $P$.
For instance, if $P(x) \jdeq B(x)\times C(x)$, then we have
\[\transfib{P}{p}{(b,c)} = \left(\transfib{B}{p}{b},\transfib{C}{p}{c}\right).\]

Finally, the type forming rules are also functorial, and if a function $f$ is built from this functoriality, then the operations $\apfunc f$ and $\apdfunc f$ can be computed based on the corresponding ones on the data going into $f$.
For instance, if $g:B\to B'$ and $h:C\to C'$ and we define $f:B\times C \to B'\times C'$ by $f(b,c)\defeq (g(b),h(c))$, then modulo the equivalence~\eqref{eq:prodeqv}, we can identify $\apfunc f$ with ``$(\apfunc g,\apfunc h)$''.

In this section, we will state and prove theorems of this sort for all the basic type forming rules.

\begin{rmk}
  In the type theory we are working with, identity types are defined simultaneously for all types by the inductive $J$-rule.
  The characterizations for particular types to be discussed in this chapter are then theorems which we have to discover and prove.
  An alternative presentation of type theory might take these characterizations as \emph{definitions} of the identity types (by induction over the construction of types), with the inductive $J$-rule then being provable.
  While such a type theory has not yet been made precise except in very simple cases, it is still helpful to think of the rules to be presented in this section as ``computation'' rules for ``evaluating'' identity types, transport, and function application.
\end{rmk}

\subsection{Cartesian product types}
\label{sec:compute-cartprod}

Given types $A$ and $B$, consider the cartesian product type $A \times B$.  
For any elements $x,y:A\times B$ and a path $p:\id[A\times B]{x}{y}$, by functoriality we can extract paths $\ap{\proj1}p:\id[A]{\proj1(x)}{\proj1(y)}$ and $\ap{\proj2}p:\id[B]{\proj2(x)}{\proj2(y)}$.
Thus, we have a function
\begin{equation}
  (\id[A\times B]{x}{y}) \;\to\; (\id[A]{\proj1(x)}{\proj1(y)}) \times (\id[B]{\proj2(x)}{\proj2(y)}).\label{eq:path-prod}
\end{equation}

\begin{thm}\label{thm:path-prod}
  For any $x$ and $y$, the function~\eqref{eq:path-prod} is an equivalence.
\end{thm}

Read logically, this says that two pairs are equal if they are equal
componentwise.  Read category-theoretically, this says that the
morphisms in a product groupoid are pairs of morphisms.  Read
homotopy-theoretically, this says that the paths in a product
space are pairs of paths.

\begin{proof}
  We need a function in the other direction:
  \begin{equation}
    (\id[A]{\proj1(x)}{\proj1(y)}) \times (\id[B]{\proj2(x)}{\proj2(y)}) \;\to\; (\id[A\times B]{x}{y}) .\label{eq:path-prod-inverse}
  \end{equation}
  By the induction rule for cartesian products, we may assume that $x$ and $y$ are both pairs, i.e.\ $x\jdeq (a,b)$ and $y\jdeq (a',b')$ for some $a,a':A$ and $b,b':B$.
  In this case, what we want is a function
  \begin{equation*}
    (\id[A]{a}{a'}) \times (\id[B]{b}{b'}) \;\to\; \big(\id[A\times B]{(a,b)}{(a',b')}\big).
  \end{equation*}
  Now by induction for the cartesian product in its domain, we may assume given $p:a=a'$ and $q:b=b'$.
  And by two path inductions, we may assume that $a\jdeq a'$ and $b\jdeq b'$ and both $p$ and $q$ are reflexivity.
  But in this case, we have $(a,b)\jdeq(a',b')$ and so we can take the output to also be reflexivity.

  It remains to prove that~\eqref{eq:path-prod-inverse} is quasi-inverse to~\eqref{eq:path-prod}.
  This is a simple sequence of inductions, but they have to be done in the right order.

  If we start with $r:\id[A\times B]{x}{y}$, then we first do a path induction on $r$ in order to assume that $x\jdeq y$ and $r$ is reflexivity.
  In this case, since $\apfunc{\proj1}$ and $\apfunc{\proj2}$ are defined by path induction,~\eqref{eq:path-prod} takes $r\jdeq \refl{x}$ to the pair $(\refl{\proj1x},\refl{\proj2x})$.
  Now by induction on $x$, we may assume $x\jdeq (a,b)$, so that this is $(\refl a, \refl b)$.
  Thus,~\eqref{eq:path-prod-inverse} takes it by definition to $\refl{(a,b)}$, which (under our current assumptions) is $r$.
  
  In the other direction, if we start with $s:(\id[A]{\proj1(x)}{\proj1(y)}) \times (\id[B]{\proj2(x)}{\proj2(y)})$, then we first do induction on $x$ and $y$ to assume that they are pairs $(a,b)$ and $(a',b')$, and then induction on $s:(\id[A]{a}{a'}) \times (\id[B]{b}{b'})$ to reduce it to a pair $(p,q)$ where $p:a=a'$ and $q:b=b'$.
  Now by induction on $p$ and $q$, we may assume they are reflexivities $\refl a$ and $\refl b$, in which case~\eqref{eq:path-prod-inverse} yields $\refl{(a,b)}$ and then~\eqref{eq:path-prod} returns us to $(\refl a,\refl b)\jdeq (p,q)\jdeq s$.
\end{proof}

From a programming perspective, it's useful to unpack this equivalence into the following data:

\newcommand{\pairpath}{\mathsf{pair}^{\mathord{=}}}
\newcommand{\projpath}[1]{\proj{#1}^{\mathord{=}}}

\begin{itemize}
\item An introduction rule for $(\id[A \times B]{x}{y})$ (this is~\eqref{eq:path-prod-inverse})
  \[
  \pairpath : (\id{\proj{1} x}{\proj{1} y}) \times (\id{\proj{1} x}{\proj{1} y}) \to {(\id x y)}
  \]
\item Elimination rules (these are the two components of~\eqref{eq:path-prod}):
  \begin{align*}
    \projpath{1} &: (\id{x}{y}) \to (\id{\proj{1} x}{\proj{1} y})\\
    \projpath{2} &: (\id{x}{y}) \to (\id{\proj{2} x}{\proj{2} y})
  \end{align*}
\item $\beta$-reduction:
  \begin{align*}
    {\projpath{1}{(\pairpath(p, q)})}
    &=_{(\id{\proj{1} x}{\proj{1} y})}
    {p} \\
    {\projpath{2}{(\pairpath(p,q)})}
    &=_{(\id{\proj{2} x}{\proj{2} y})}
    {q}
  \end{align*}
\item $\eta$-equivalence: For any $r : \id[A \times B] x y$
  \[
  \id{r}{\pairpath(\projpath{1} (r), \projpath{2} (r)) }
  \]
\end{itemize}
Moreover, reflexivity, inverses, and composition are defined componentwise:
\begin{align*}
  {\refl{(z : A \times B)}}
  &= {\pairpath (\refl{\proj{1} z},\refl{\proj{2} z})} \\
  {\opp{p}}
  &= {\pairpath \big(\opp{(\projpath{1} p)},\, \opp{(\projpath{2} p)}\big)} \\
  {{p \ct q}}
  &= {\pairpath \big({\projpath{1} p} \ct {\projpath{1} q},\,{\projpath{2} p} \ct {\projpath{2} q}\big)}
\end{align*}
The same is true for all the higher groupoid structure considered in \S\ref{sec:equality}.
All of these equations can be derived by using path induction on the given paths and then returning reflexivity.  

We now consider transport in a product of dependent types.
Given dependent types $ A, B : Z \to \type$, we abusively write $A\times B:Z\to \type$ for the dependent type defined by $(A\times B)(z) \defeq A(z) \times B(z)$.
Now given $p : \id[Z]{z}{w}$ and $x : A(z) \times B(z)$, we can transport $x$ along $p$ to obtain an element of $A(w)\times B(w)$.

\begin{thm}\label{thm:trans-prod}
  In the above situation, we have
  \[
  \id[A(y) \times B(y)]
  {\transfib{A\times B}px}
  {(\transfib{A}{p}{\proj{1}x}, \transfib{B}{p}{\proj{2}x})}
  \]
\end{thm}
\begin{proof}
  By path induction, we may assume $p$ is reflexivity, in which case we have
  \begin{align*}
    \transfib{A\times B}px&\jdeq x\\
    \transfib{A}{p}{\proj{1}x}&\jdeq \proj1x\\
    \transfib{A}{p}{\proj{2}x}&\jdeq \proj2x.
  \end{align*}
  Thus, it remains to show $x = (\proj1 x, \proj2x)$, which follows by induction on $x$.
\end{proof}

Finally, we consider the functoriality of $\apfunc{}$ under cartesian products.
Suppose given types $A,B,A',B'$ and functions $g:A\to A'$ and $h:B\to B'$; then we can define a function $f:A\times B\to A'\times B'$ by $f(x) \defeq (g(\proj1x),h(\proj2x))$.

\begin{thm}\label{thm:ap-prod}
  In the above situation, given $x,y:A\times B$ and $p:\proj1x=\proj1y$ and $q:\proj2x=\proj2y$, we have
  \[ \id[(f(x)=f(y))]{\ap{f}{\pairpath(p,q)}} {\pairpath(\ap{g}{p},\ap{h}{q})}. \]
\end{thm}
\begin{proof}
  Note first that the above equation is well-typed.
  On the one hand, since $\pairpath(p,q):x=y$ we have $\ap{f}{\pairpath(p,q)}:f(x)=f(y)$.
  On the other hand, since $\proj1(f(x))\jdeq g(\proj1x)$ and $\proj2(f(x))\jdeq h(\proj2x)$, we also have $\pairpath(\ap{g}{p},\ap{h}{q}):f(x)=f(y)$.

  Now, by induction, we may assume $x\jdeq(a,b)$ and $y\jdeq(a',b')$, in which case we have $p:a=a'$ and $q:b=b'$.
  Thus, by path induction, we may assume $p$ and $q$ are reflexivity, in which case the desired equation holds judgmentally.
\end{proof}


\subsection{$\Sigma$-types}
\label{sec:compute-sigma}

To find out what it means to be a path in a $\Sigma$-type suppose that we have a path $p:w=w'$ in $\sm{x:A}P(x)$. Then we get $\ap{\proj{1}}{p}:\proj{1}(w)=\proj{1}(w')$. We cannot directly ask whether $\proj{2}(w)$ is identical to $\proj{2}(w')$ since they don't have to be in the same type. However, we can transport $\proj{2}(w)$ along the path $\ap{\proj{1}}(p)$, which does give us a term of the same type as $\proj{2}(w')$. By path induction, we see that we also obtain a path $\trans{\ap{\proj{1}}{p}}{\proj{2}(w)}=\proj{2}(w')$. The next theorem states that we can reverse this process.

\begin{thm}
Suppose that $P:A\to\type$ is a dependent type over a type $A$ and let $w,w^\prime:\sm{x:A}P(x)$. Then there is an equivalence
\begin{equation*}
\eqv{w=w'}{\sm{p:\proj{1}(w)=\proj{1}(w')}\trans{p}{\proj{2}(w)}=\proj{2}(w^\prime)}.
\end{equation*}
\end{thm}

\begin{proof}
We define for any $w,w':\sm{x:A}P(x)$ a function $f(w,w')$ of type
\begin{equation*}
(w=w')\to\sm{p:\proj{1}(w)=\proj{1}(w')}\trans{p}{\proj{2}(w)}=\proj{2}(w^\prime)
\end{equation*}
by path induction, with 
\begin{equation*}
f(w,w,\refl{w})\defeq(\refl{\proj{1}(w)},\refl{\proj{2}(w)}).
\end{equation*}
We want to show that $f$ is an isomorphism, so we can find a section $g(w,w')$ of $f(w,w')$ by finding a function $G(w,w')$ of type
\begin{equation*}
\prd{p:\proj 1(w)=\proj 1(w')}{q:\trans p{\proj 2(w)}=\proj 2(w')}\mathsf{hFiber}(f(w,w'),(p,q))
\end{equation*}
for each $w,w':\sm{x:A}P(x)$. To do this we will first use the induction principle of dependent sums, i.e.\ it is enough to find a function $G((x,u),(y,v))$ of type
\begin{equation*}
\prd{p:x=y}{q:\trans{p}{u}=v}\hfiber{f((x,u),(y,v))}{(p,q)}
\end{equation*}
This is obvious by induction on $p$ followed by induction on $q$ and we get
\begin{equation*}
G((x,u),(x,u),(\refl{x},\refl{u}))\defeq(\refl{(x,u)},\refl{(\refl{x},\refl{u})}).
\end{equation*}
This gives the function $g(w,w')\defeq\proj{1}\circ G(w,w')$ which is a section of $f(w,w')$ by construction. To show that there is a path $g(w,w',f(w,w',\alpha))=\alpha$ for any $\alpha:w=w'$ we use path induction on $\alpha$ and destruction on $w$. The result follows immediately.
\end{proof}

\begin{thm}
Suppose we have a dependent type $P:A\to\type$ and a dependent type $Q:(\sum(x:A),\ P(x))\to\type$. Then we get the dependent type
\begin{equation*}
x:A\vdash \sum(u:P(x)),\ Q(x,u):\type
\end{equation*}
For any path $p:x=y$ and any $(u,z):\sum(u:P(x)),\ Q(x,u)$ we have
\begin{equation*}
p\cdot(u,z)=(\trans{p}{u},\trans{\mathsf{lift}(u,p)}{z}).
\end{equation*}
The path $\mathsf{lift}(u,p)$ is defined in theorem \ref{thm:path_lifting}.
\end{thm}

\begin{proof}
Immediate by path induction.
\end{proof}

\subsection{$\Pi$-types}

Given $A$ and $B : A \to \type$, consider the dependent function type $\prd{x:A}B(x)$.
A path in $\prd{x:A} B(x)$ is given by a homotopy:  

\[
\eqv{(\id[\prd{x:A} B(x)]{f}{g})}{\prd{x:A} \id[B(x)]{(f x)}{(g x)}}
\]

Again it is useful to break this into 

\begin{itemize}
\item An introduction rule for {(\id[\prd{x:A} B(x)]{f}{g})}, function extensionality
  \[
  \funext : (\prd{x:A} \id[B(x)]{(f x)}{(g x)}) \to {(\id[\prd{x:A} B(x)]{f}{g})}
  \]
\item An elimination rule: for all $f,g : \prd{x:A} B(x)$
  \[
  \happly{-}{-} : \id{f}{g} \to \prd{\alpha : \id{x}{y}} \id{\transport{B}{\alpha} \: {(f x)}}{(g y)}
  \]
\item $\beta$-reduction: 
  \[
  \begin{array}{l}
  \id{\happly \: {\funext{(x \mapsto \alpha(x))}} \: {\refl{a}}}{\alpha(a)}
  \end{array}
  \]
\item $\eta$-equivalence: For any $\alpha : \id[\prd{x:A} B(x)] f g$
  \[
  \id{\alpha}{\funext (x \mapsto \happly \: \alpha \: x)}
  \]
\end{itemize}

%% FIXME: where do the rules for \alpha[\delta] go in this style?

Identity, inverses, and composition:
\[
\begin{array}{l}
\refl{(f : \prd{x:A} B)} = \funext(x \mapsto \refl{f x}) \\
\opp{\alpha} = \funext (x \mapsto \opp{(\happly \: {\alpha} \: {\refl x})})  \\
{\alpha} \ct \beta = \funext (x \mapsto {(\happly \: {\alpha} \: {\refl x}) \ct (\happly \: {\beta} \: {\refl x})})  \\
\end{array}
\]

\newcommand{\fcomp}{\circ}

Transport, first for non-dependent functions: given $\alpha : \id {a_0} {a_0'}$
and $f : A(a_0) \to B(a_0)$, 
\[
\begin{array}{l}
\transport{x_0:A_0 \mapsto A(x_0) \to B(x_0)}{\alpha} \: f = 
   (\transport{x_0:A_0 \mapsto B(x_0)}{\alpha}) \fcomp f \fcomp (\transport{x:A_0 \mapsto A(x_0)}{\opp \alpha})
\end{array}
\]

Transport for $\Pi$:  
\[
\begin{array}{l}
\transport{x_0:A_0 \mapsto \prd{x : A(x_0)} B(x_0)}{\alpha} \: f =  \\
   x \mapsto 
   \transport{(p : \sm {x_0:A_0} A) \mapsto B(\proj{1} \: p, \proj{2} \: p)}{\alpha^{\mathord{-}}(x) } 
      \: (f (\transport{x:A_0 \mapsto A(x)}{\opp \alpha}\:  x))
\end{array}
\]
where 
\[
\alpha^-(x) : \id[\sm {x_0:A_0} A(x_0)] {(a_0 , \transport{x_0 \mapsto A(x_0)} {\opp \alpha} \: x)} {(a_0' , x)}
\]
can be defined by path induction on $\alpha$.  
%%FIXME: should discuss this with sigma types

\subsection{The Universe}

A path in $\type$ is given by univalence

\[
\eqv{(\id[\type]{A}{B})}{\eqv A B}
\]

Again it is useful to break this into 

\newcommand\isequiv{\mathsf{isEquiv}}

\begin{itemize}
\item An introduction rule for {(\id[\type]{A}{B})}:
  \[
  \ua{} : {\eqv A B} \to (\id[\type]{A}{B})
  \]
\item The elimination rule is transport at $X:\type \mapsto X$:
  \[
  \transport{X \mapsto X}{} : \id{A}{B} \to (A \to B)
  \]
\item $\beta$-reduction: 
  \[
  \begin{array}{l}
  \id{\transport{X \mapsto X} \: (\ua {(f, fIsEquiv)})}{f}
  \end{array}
  \]
\item $\eta$-equivalence: For any $\alpha : \id A B$
  \[
  \id{\alpha}{\ua {(\transport{X \mapsto X}(\alpha) , \beta)}}
  \]
  where $\mathsf{transportIsEquiv} : \isequiv{\transport{X \mapsto X}(\alpha)}$ can be
  defined by doing path induction on $\alpha$, at which point it
  suffices to show that the identity function is an equivalence.  
\end{itemize}

Identity, inverses, and composition: (FIXME: pick a specific definition
of equivalence?)
\[
\begin{array}{l}
\refl{A} = \ua{\idfunc} \\
\opp{\alpha} = \ua {(\transport {X \mapsto X} {\opp \alpha}, \mathsf{transportIsEquiv} \: (\opp \alpha))} \\ 
{\alpha} \ct \beta = ? \\
\end{array}
\]

\subsection{Identity Type}

When we know what \id[A]{}{} is, \id[ {\id[A]{}{}} ]{}{} follows:

Transport, when $A$ is non-dependent:
\[
\begin{array}{l}
\transport{x_0:A_0 \mapsto \id[A] {a_1(x_0)}{a_2(x_0)}} {\alpha_0}{\alpha} = 
\opp{(\map{a_1}{\alpha_0})} \ct \alpha \ct \map{a_2}{\alpha_0}
\end{array}
\]

Useful special cases:
\[
\begin{array}{l}
\transport{x:A \mapsto \id[A] {a}{x}} {\alpha_0} \: {\alpha} = \alpha \ct \alpha_0 \\
\transport{x:A \mapsto \id[A] {x_0}{a}} {\alpha_0} \: {\alpha} = \opp {\alpha_0} \ct \alpha \\
\end{array}
\]

Transport, when $A$ is dependent:
\[
\begin{array}{l}
\transport{x_0:A_0 \mapsto \id[A(x_0)] {a_1(x_0)}{a_2(x_0)}} {\alpha_0} \: {\alpha} = \\
\opp{(\map{a_1}{\alpha_0})} \ct \mapdep{(\transport{A}{\alpha_0})}{\alpha} \ct \map{a_2}{\alpha_0}
\end{array}
\]

\subsection{Higher Inductives}

\newcommand{\sone}{\mathsf{S^1}}

Consider a higher inductive type such as $\sone$.  The definition of the
higher inductive type does not immediately characterize
\id[\sone]{x}{y}---which is good, because the calculation of higher
homotopy groups can be a significant theorem, so we don't want it to be
baked into the definitions.  However, we will often be able to prove a
theorem characterizing the loop space, which follows the above form.
For example, the proof in Chapter~\ref{cha:homotopy} that the fundamental
group of the circle is the integers plays this role:

\begin{itemize}
\item An introduction rule for \id[\sone]{\mathsf{base}}{\mathsf{base}}:
  \[
  \mathsf{loopToThe} : \mathbb{Z} \to \id{\mathsf{base}}{\mathsf{base}}
  \]
\item An elimination rule:
  \[
  \mathsf{encode} : \id{\mathsf{base}}{\mathsf{base}} \to \mathbb{Z}
  \]
\item With $\beta$ and $\eta$ rules stating that these are mutually inverse.
\end{itemize}

It's less clear that you want to think about identity, inverses, and
composition as being defined through this encoding (rather than thinking
of them as constructors), but you can:

\[
\begin{array}{l}
\refl{\mathsf{base}} = \mathsf{loopToThe} \: 0 \\
\opp{\alpha} = \mathsf{loopToThe} \: (- (\mathsf{encode} \: \alpha)) \\
\alpha \ct \beta = \mathsf{loopToThe} \: ((\mathsf{encode} \: \alpha) + (\mathsf{encode} \: \beta)) \\
\end{array}
\]

This changes the representation of the group structure
from the identity type to an explicit representation, as the free group
on one generator (the additive group on the integers).  

FIXME: say something about map

\section{Examples}

\subsection{Monoid}


% Local Variables:
% TeX-master: "main"
% End:
