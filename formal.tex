\chapter{The Rules of Type Theory}
\bgroup                         % restrict the scope of our macros to this file

\newcommand{\Okay}{\mathop{\textsf{okay}}}

\newcommand{\production}{\vcentcolon\vcentcolon=}

\newcommand{\mkbox}[1]{\ensuremath{#1}}

\newcommand{\app}{\mathsf{app}}

\newcommand{\gothic}{\mathfrak}
\newcommand{\gP}{{\gothic p}}
\newcommand{\gM}{{\gothic M}}
\newcommand{\gN}{{\gothic N}}
\newcommand{\rats}{\mathbb{Q}}
\newcommand{\ints}{\mathbb{Z}}

\newcommand{\lbr}{\lbrack\!\lbrack}
\newcommand{\rbr}{\rbrack\!\rbrack}
\newcommand{\sem}[2] {\lbr #1 \rbr_{#2}}  % interpretation of the terms
\newcommand{\APP}[2] {{\sf app}(#1,#2)}  % interpretation of the terms
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Con}{{\sf Con}}
\newcommand{\Elem}{{\sf Elem}}
\newcommand{\myId}{1}
\newcommand{\mypp}{{\sf p}}
\newcommand{\qq}{{\sf q}}
\newcommand{\mySp}{{\sf Sp}}
\newcommand{\conv}{\sim}
\newcommand{\LIM}{{\sf lim}}
\newcommand{\nn}{{\sf n}}
\newcommand{\Fam}{{\sf Fam}}

The goal of this appendix is to summarize the notation and inference rules of
the type theory used in this book.

\section{Syntax, informally}

\subsection*{The Raw Syntax}

The objects and types of our type theory may be written as {\em terms} or {\em
  expressions} using the following syntax, which is an extension of
$\lambda$-calculus with {\em variables} $x, x',\dots$, {\em primitive}
constants $c,c',\dots$, {\em defined} constants $f,f',\dots$, and term forming
operations
\[
  t \production x \mid \lam{x} t \mid t(t') \mid c \mid f
\]

We follow the usual convention about free and bound variables.  We write
$B[a/x]$ for the substitution of a term $a$ for free occurrences of the
variable $x$ in the term $B$, with possible renaming for avoiding
capture of variables, as discussed in \autoref{sec:function-types}.
Alternatively, we may regard $B$ as an {\em abstraction}, which signifies that
a variable, $x$, say, is bound within $B$ and can be renamed without changing
the identity of $B$.  In that case, we'll let $B[a]$ denote the result of
substituting $a$ for the (outermost) variable bound in $B$ and removing the
abstraction that recorded its presence and its name.  We use $B[a_1,\dots,a_n]$
as an abbreviation for the repeated substitution $B[a_1]\dots[a_n]$.

We use $t(t_1,\dots,t_n)$ as an abbreviation for the repeated application
$t(t_1)(t_2)\dots (t_n)$.  We may also use {\em infix} notation, writing $t_1\;
\star\; t_2$ for $\star(t_1,t_2)$ when $\star$ is a primitive or defined
constant.

Each defined constant will have zero, one or more {\em defining equations}.
There will be two kinds of defined constant.  An {\em explicit} defined
constant $f$ will have a single defining equation
  \[ f(x_1,\dots,x_n)\defeq t,\]
where $t$ does not involve $f$.  

As an example, we introduce the explicit defined constant $\circ$, for
composition of functions, with defining equation
  \[ \circ (x,y)(z) \defeq x(y(z)),\]
and we use infix notation $x\circ y$ for $\circ(x,y)$.

The second kind of defined constant will be used in connection with a form of type having some primitive constants that are used to introduce elements into types of that form.  With each such primitive constant $c$ there will be a defining equation of the form
\[
  f(x_1,\dots,x_n,c(y_1,\dots,y_m)) \defeq t,
\]
where now $f$ may occur in $t$, but now only in such a way that, in the context
where $f$ is introduced it will be a totally defined typed function.  The
paradigm examples of such defined functions are the functions defined by
primitive recursion on the natural numbers.  We may call this kind of
definition of a function a {\em total recursive definition}.  In computer
science and logic this kind of definition of a function on a recursive data
type has been called a {\em definition by structural recursion}.

We introduce the notion of {\em convertibility} $t \conv t'$ between terms $t$
and $t'$ as the equivalence relation generated by all instances of the
elementary reduction
\[
  (\lam{x} t)(u) \conv t[u/x].
\]
and by all instances of defining equations, such as the one for $x \circ y$
presented above, and by those to be introduced below.


\subsection*{The forms of judgment}

In our type theory, we mainly derive {\em typing judgments} of the form $a:A$,
which is read as asserting that $a$ is an object of type $A$.

In general such judgments are formulated in an ambient a {\em context}, which
is of the form
\[
  \Gamma =  x_1:A_1, x_2:A_2,\dots,x_n:A_n
\]
Here each expression $A_i$ is an expression containing only the variables
$x_1,\dots,x_{i-1}$ freely.  The presence of a context $\Gamma$ signifies that
each variable $x_i$ is assumed to have type $A_i$.

We use the notation
\[
  \Gamma \vdash a:A
\]
to assert the judgment that the object $a$ has type $A$ in the context
$\Gamma$.  Here $a$ and $A$ are terms in which only the variables declared in
$\Gamma$ appear freely.  Under the assumption that a context $\Gamma$ is
present in the background, we may write simply
\[
  a:A
\]
When $\Gamma$ is empty, we may write simply
\[
  \vdash a:A
\]

Such judgments will be justified only for contexts that are well-formed.  We
introduce a primitive judgment of the form
\[
  \Gamma \vdash \Okay
\]
to express that notion.  The intuitive idea will be that each $A_i$ is a valid
type in the context $x_1:A_1, x_2:A_2,\dots,x_{i-1}:A_{i-1}$.  We can express that idea with 
the rule
\begin{itemize}
\item if $\Gamma =  x_1:A_1, x_2:A_2,\dots,x_n:A_n$, and $\Gamma \vdash \Okay$, then, for any $i$, $\Gamma \vdash x_i : A_i$.
\end{itemize}
We get started by asserting that the empty context is okay:
\begin{itemize}
\item $\vdash \Okay$
\end{itemize}
There are also {\em equality judgments} $t \jdeq u : A$.  They are defined by
the following rule.
\begin{itemize}
\item if $t:A$, $u:A$, and $t \conv u$, then $t \jdeq u : A$
\end{itemize}
Equality is an equivalence relation.

%% \begin{itemize}
%% \item if $t:A$, then $t \jdeq t : A$
%% \item if $t \jdeq u : A$, then $u \jdeq t : A$
%% \item if $t \jdeq u : A$ and $u \jdeq v : A$, then $t \jdeq v : A$
%% \end{itemize}

The following conversion rule allows us to replace a type by one equal to it in
a typing judgment.
\begin{itemize}
\item if $a:A$ and $A \jdeq B$ then $a:B$
\end{itemize}

\subsection*{Type Universes}

We introduce a hierarchy of {\em universes} denoted by primitive constants
$\UU_n$, for each $n=0,1,\ldots$.  They satisfy the following rules.  The first
two say that the universes form a sequential hierarchy of types, and the third expresses
the idea that an object of a universe can serve as a type and stand to the
right of a colon in judgments.

\begin{itemize}
\item $\UU_m : \UU_n$ for $m < n$
\item if $A:\UU_m$ and $m \le n$, then $A:\UU_m$.
\item if $\Gamma \vdash A : \UU_n$, and $x$ is a new variable, then $\Gamma, x:A \vdash \Okay$
\end{itemize}

In the body of the book, an equality judgment $A \jdeq B : \UU_n$ between types
$A$ and $B$ is usually abbreviated to $A \jdeq B$.  This is an instance of
typical ambiguity, and the choice of $n$ doesn't affect the validity of the judgment.

\subsection*{$\Pi$ types}

We introduce a primitive constant $c_\Pi$.  An expression of the form
$c_\Pi(A,\lam{a} B)$ will be written as $\prd{a:A}B$.  Judgments concerning
such expressions and expressions of the form $\lam{x} b$ are introduced by the following rules.

\begin{itemize}
\item if $\Gamma \vdash A:\UU_n$ and $\Gamma,a:A \vdash B:\UU_n$, then $\Gamma \vdash \prd{a:A}B : \UU_n$
\item if $\Gamma, a:A \vdash b:B$ then $\Gamma \vdash (\lam{a} b) : (\prd{a:A} B)$
\item if $g:\prd{a:A} B$ and $t:A$ then $g(t):B[t/a]$
\end{itemize}

If $a$ does not occur freely in $B$, we abbreviate $\prd{a:A} B$ as $A
\rightarrow B$ and derive the following rule.

\begin{itemize}
\item if $g:A \rightarrow B$ and $t:A$ then $g(t):B$
\end{itemize}

\subsection*{Natural numbers}

The type of natural numbers is obtained by introducing primitive constants
$\N$, $0$, and $\suc$ with the following rules.
\begin{itemize}
  \item $\N : \UU_0$,
  \item $0:\N$,
  \item $\suc:\N\rightarrow \N$.
\end{itemize}

Furthermore, we can define functions by primitive recursion.  If we have
$C : \N \rightarrow \UU_k $ we can introduce a defined constant $f:\prd{n:\N}C(n)$ whenever we have
  \begin{align*}
    d & : C(0) \\
    e & : \prd{x:\N}(C(x)\rightarrow C(\suc (x)))
  \end{align*}
with the defining equations
  \begin{align*}
    f(0) & \defeq d \\
    f(\suc (x)) & \defeq e(x,f(x))
  \end{align*}
 
As usual $C,d,e$ may have been obtained in an implicit context $\Gamma$ in which variables $x_1,\ldots,x_n$ are declared.  Then there will be the extra implicit parameters $x_1,\ldots,x_n$, so that the fully explicit primitive recursion schema is
  \begin{align*}
    f(x_1,\dots,x_n,0) & \defeq d[x_1,\dots,x_n] \\
    f(x_1,\dots,x_n,\suc (x)) & \defeq e[x_1,\dots,x_n,x,f(x_1,\dots,x_n,x)]
  \end{align*}

\subsection*{The finite types}

We introduce primitive constants $\tt$, $\bfalse$, $\btrue$, $\emptyt$,
$\unit$, $\bool$ satisfying the following rules.

\begin{itemize}
\item $\emptyt : \UU_0$, $\unit : \UU_0$, $\bool : \UU_0$,
\item $\ttt:\unit$, $\bfalse:\bool$, $\btrue:\bool$.
\end{itemize}

Given $C : \emptyt \rightarrow \UU_n$ we can introduce a defined constant $f:\prd{x:\emptyt} C(x)$, with no defining equations.

Given $C : \unit \rightarrow \UU_n$ and $c : C(\ttt)$ we can introduce a defined constant $f:\prd{x:\unit} C(x)$, with defining equation $f(\ttt) \defeq c$.

Given $C : \bool \rightarrow \UU_n$, $c : C(\bfalse)$, and $c' : C(\btrue)$, we can introduce a defined constant $f:\prd{x:\bool} C(x)$, with defining equations
$f(\bfalse)\defeq c$ and $f(\btrue)\defeq c'$.

\subsection*{$\Sigma$-Types}

We introduce primitive constants $c_\Sigma$ and $c_{\mathsf{pair}}$.  An
expression of the form $c_\Sigma(A,\lam{a} B)$ will be written as $\sm{a:A}B$,
and an expression of the form $c_{\mathsf{pair}}(a,b)$ will be written as $\tup
a b$.  We write $A\times B$ instead of $\sm{x:A} B$ if $x$ is not free in $B$.

Judgments concerning such expressions are introduced by the following
rules.

\begin{itemize}
\item if $A:\UU_n$ and $B: A \rightarrow \UU_n$, then $\sm{a:A}B(a) : \UU_n$
\item if, in addition, $x:A$ and $y:B(x)$, then $\tup x y:\sm{a:A}B(a)$
\end{itemize}

If we have $A$ and $B$ as above, $C : \sm{a:A}B(a) \rightarrow \UU_m$, and
\[
  d:\prd{x:A}{y:B(x)} C(\tup x y)
\]
we can introduce a defined constant 
\[
  f:\prd{p:\sm{a:A}B(a)} C(p)
\]
with the defining equation
\[
  f(\tup x y)\defeq d(x,y).
\]

\subsection*{Coproduct types}
We introduce primitive constants $c_+$, $c_\inlsym$, and $c_\inrsym$.
We will write $A+B$ instead of $c_+(A,B)$, $\inl(a)$ instead of
$c_\inlsym(a)$, and $\inr(a)$ instead of $c_\inrsym(a)$.

\begin{itemize}
\item if $A,B : \UU_n$ then $A + B : \UU_n$
\item moreover, $\inl: A \rightarrow A+B$ and $\inr: B \rightarrow A+B$
\end{itemize}

If we have $A$ and $B$ as above, $C : A+B \rightarrow \UU_m$, $c:\prd{a:A} C(\inl(a))$, and $c':\prd{b:B} C(\inr(b))$,
then we can introduce a defined constant $f:\prd{x:A+B}C(x)$ with the defining equations
\begin{align*}
  f(\inl(a)) & \defeq c(a) \\
  f(\inr(b)) & \defeq c'(b)
\end{align*}

\subsection*{$W$-Types}

For $W$-types we introduce primitive constants $c_\wtypesym$ and $c_\suppsym$.
An expression of the form $c_\wtypesym(A,\lam{a} B)$ will be written as
$\wtype{a:A}B$, and an expression of the form $c_\suppsym(x,u)$ will be written
as $\supp(x,u)$

\begin{itemize}
\item if $A:\UU_n$ and $B: A \rightarrow \UU_n$, then $\wtype{a:A}B : \UU_n$
\item if moreover, $a:A$ and $u:B(a)\rightarrow \wtype{a:A}B$ then $\supp(a,u):\wtype{a:A}B$.
\end{itemize}
 
Here also we can define functions by total recursion.  If we have $A$ and $B$
as above and $C : \wtype{a:A}B \rightarrow \UU_m$, then we can introduce a defined constant
$f:\prd{z:\wtype{a:A}B} C(z)$ whenever we have
\[
  d:\prd{x:A}{u:B(x) \rightarrow \wtype{a:A}B}((\prd{y:B}C(u(y))) \rightarrow C(\supp(x,u))
\]
with the defining equation
\[
  f(\supp(x,u)) \defeq d(x,u,f\circ u)
\]

\subsection*{Identity types}

We introduce primitive constants $c_\idsym$ and $c_\reflsym$.  We will write
$\id[A] a b$ for $c_\idsym(A,a,b)$ and $\refl a$ for $c_\reflsym(A,a)$, when
$a:A$ is understood.

\begin{itemize}
\item if $A : \UU_n$, $a:A$, and $b:A$ then $\id[A] a b : \UU_n$
\item if, moreover, $a:A$, then $\refl a :\id[A] a a $.
\end{itemize}

If $\Gamma, y:A, z:\id[A] a y \vdash C : \UU_m$ and $d:C[a/y,\refl{a}/z]$ then we can introduce a defined constant 
\[
  f:\prd{y:A}{z:\id[A] a y} C
\]
with defining equation
\[
  f(a,\refl{a})\defeq d.
\]

\section{Syntax, more formally}

\bgroup % restrict the following macros to this section

%% Basic syntax of type theory:
% judgements
\newcommand{\oftype}{\mathord{:}}
\newcommand{\types}{\vdash}
\newcommand{\myType}{\textsf{ type}} %  \newcommand{\type}{\textsf{type}}
\newcommand{\cxt}{\textsf{cxt}}
\newcommand{\emptycxt}{[\ ]}
% rules:
\newcommand{\form}{\textsc{form}}
\newcommand{\intro}{\textsc{intro}}
\newcommand{\appRule}{\textsc{app}}
\newcommand{\elim}{\textsc{elim}}
\newcommand{\comp}{\textsc{comp}}
\newcommand{\Weak}{\mathsf{Wkg}}
\newcommand{\Vble}{\mathsf{Vble}}
\newcommand{\Exch}{\mathsf{Exch}}
\newcommand{\Subst}{\mathsf{Subst}}
% type constructors of the theory
\newcommand{\synId}{\mathsf{Id}}
\newcommand{\synPi}{\mathsf{\Pi}}
\newcommand{\synSigma}{\mathsf{\Sigma}}
\newcommand{\synW}{\mathsf{W}}
\newcommand{\synOne}{\mathsf{1}}
\newcommand{\synZero}{\mathsf{0}}
\newcommand{\synPlus}{+}
\newcommand{\synU}{\mathsf{U}}
% term constructors of the theory
\newcommand{\el}{\mathsf{El}}
\newcommand{\synrefl}{\mathsf{refl}}
\newcommand{\synlambda}{\mathsf{\lambda}}
% defined above: \newcommand{\app}{\mathsf{app}}
\newcommand{\myRefl}{\mathsf{refl}} % \newcommand{\refl}{\mathsf{refl}}
\newcommand{\synsup}{\mathsf{sup}}
\newcommand{\synz}{\mathsf{z}}
\newcommand{\syno}{\mathsf{o}}
\newcommand{\synw}{\mathsf{w}}
% constructors on the internal universe
\newcommand{\synpi}{\boldsymbol{\pi}}
\newcommand{\synsigma}{\boldsymbol{\sigma}}
\newcommand{\synid}{\mathsf{id}}

%% Defined syntax of type theory:
\let\syn\mathsf
\newcommand{\synisHIso}{\mathsf{isHIso}}
\newcommand{\synHIso}{\mathsf{HIso}}
\newcommand{\synisEquiv}{\mathsf{isEquiv}}
\newcommand{\synEquiv}{\mathsf{Equiv}}
\newcommand{\synisAdjEquiv}{\mathsf{isAdjEquiv}}
\newcommand{\synAdjEquiv}{\mathsf{AdjEquiv}}
\newcommand{\synHEquivStrux}{\mathsf{HEquivStrux}}
\newcommand{\synHEquiv}{\mathsf{HEquiv}}
\newcommand{\synHFib}{\mathsf{hFib}}
\newcommand{\synHomLHInv}{\mathsf{HomLInv}}
\newcommand{\synHomRHInv}{\mathsf{HomRInv}}
\newcommand{\synLHInv}{\mathsf{LInv}}
\newcommand{\synRHInv}{\mathsf{RInv}}
\newcommand{\synisUnivalent}{\mathsf{isUnivalent}}
\newcommand{\synisContr}{\mathsf{isContr}}
\newcommand{\synisWEq}{\mathsf{isWEq}}
\newcommand{\synWEq}{\mathsf{WEq}}

Our presentation of the structural rules is based largely on
\cite{hofmann:syntax-and-semantics}, which also includes a full construction of
the syntax.  Our selection of logical rules, and in particular our treatment of
the universe, follows \cite{martin-lof:bibliopolis}.

We take as basic the judgment forms
\begin{mathpar}
  \Gamma \types A\myType
\and
  \Gamma \types A = A'\myType
\and
  \Gamma \types a : A
\and
  \Gamma \types a = a' : A.
\end{mathpar}
We treat contexts as a derived judgment, $\types \Gamma\ \cxt$. 

\subsection*{Structural Rules} \label{subsec:structural-rules}

The structural rules of the type theory are (where $\mathcal{J}$ may be any the
conclusion of any of the judgment forms):

\begin{mathpar}
  \inferrule*[right=$\Vble$]{\types \Gamma,\ x \oftype A,\ \Delta\ \cxt}{\Gamma,\ x \oftype A,\ \Delta \types x : A}
\and
  \inferrule*[right=$\Subst$]{\Gamma \types a : A \\ \Gamma,\ x \oftype A,\ \Delta \types \mathcal{J}}{\Gamma,\ \Delta[a/x] \types \mathcal{J}[a/x]}
\and
  \inferrule*[right=$\Weak$]{\Gamma \types A\myType \\ \Gamma,\ \Delta \types \mathcal{J}}{\Gamma,\ x \oftype A,\ \Delta \types \mathcal{J}}
\end{mathpar}

Definitional equality (also known as syntactic or judgmental equality):
\begin{mathparpagebreakable}
  \inferrule*{\Gamma \types A\myType}{\Gamma \types A = A\myType} 
\and
  \inferrule*{\Gamma \types A=B\myType}{\Gamma \types B = A\myType}
\and
  \inferrule*{\Gamma \types A=B\myType \\ \Gamma \types B=C \myType}{\Gamma \types A = C\myType}
\and
  \inferrule*{\Gamma \types a : A}{\Gamma \types a = a : A}
\and
  \inferrule*{\Gamma \types a=b : A}{\Gamma \types b=a : A}
\and
  \inferrule*{\Gamma \types a=b : A \\ \Gamma \types b=c : A}{\Gamma \types a=c : A}
\and
  \inferrule*{\Gamma \types a : A \\ \Gamma \types A = B \myType}{\Gamma \types a : B}
\and
  \inferrule*{\Gamma \types a = b : A \\ \Gamma \types A = B \myType}{\Gamma \types a = b : B}
\end{mathparpagebreakable}

Additionally, in the logical rules below, we assume rules stating that each constructor preserves definitional equality in each of its arguments; for instance, along with the $\synPi$-\intro\ rule, we assume the rule
\[\inferrule*[right=$\synPi$-\intro-eq]{\Gamma \types A = A'\myType \\ \Gamma,\ x \oftype A \types B(x) = B'(x)\myType \\ \Gamma,\ x \oftype A \types b(x) = b'(x) : B(x)}{\Gamma \types \lambda x \oftype A.b(x) = \lambda x \oftype A'.b'(x) : \synPi_{x \oftype A} B(x)}\]

\subsection*{Logical Constructors} \label{subsec:logical-rules}

\paragraph*{$\synPi$-types} (Dependent products; dependent function types).

\begin{mathparpagebreakable}
  \inferrule*[right=$\synPi$-\form]{\Gamma,\ x \oftype A \types B(x)\myType}{\Gamma \types \synPi_{x \oftype A} B(x)\myType}
\and
  \inferrule*[right=$\synPi$-\intro]{\Gamma,\ x \oftype A \types B(x)\myType \\ \Gamma,\ x \oftype A \types b(x) : B(x)}{\Gamma \types \lambda x \oftype A.b(x) : \synPi_{x \oftype A} B(x)}
\and
  \inferrule*[right=$\synPi$-\appRule]{\Gamma \types f \oftype \synPi_{x \oftype A} B(x) \\ \Gamma \types a : A}{\Gamma \types \textsf{app} (f, a) : B(a)}
\and
  \inferrule*[right=$\synPi$-\comp]{\Gamma,\ x \oftype A \types B(x)\myType \\ \Gamma,\ x \oftype A \types b(x) : B(x) \\ \Gamma \types a : A}{\Gamma \types \textsf{app}(\lambda x \oftype A .b(x), a)=b(a) : B(a)}
\end{mathparpagebreakable}

As a special case of this, when $B$ does not depend on $x$, we obtain the ordinary function type $[A, B] := \synPi_{x \oftype A} B$. \\

\paragraph*{$\synSigma$-types}  (Dependent sums; disjoint sums.)

\begin{mathparpagebreakable}
  \inferrule*[right=$\synSigma$-\form]{\Gamma \types A\myType \\ \Gamma,\ x \oftype A \types B(x)\myType}{\Gamma \types \synSigma_{x \oftype A} B(x)\myType}
\and
  \inferrule*[right=$\synSigma$-\intro]{\Gamma \types A\myType \\ \Gamma,\ x \oftype A \types B(x)\myType}{\Gamma,\ x \oftype A,\ y \oftype B(x) \types \textsf{pair} (x, y) : \synSigma_{x \oftype A} B(x)}
\and
  \inferrule*[right=$\synSigma$-\elim]{\Gamma,\ z \oftype \synSigma_{x \oftype A} B(x) \types C(z)\myType \\ \Gamma,\ x \oftype A,\ y \oftype B(x) \types d(x,y) : C(\textsf{pair}(x, y))}{\Gamma,\ z \oftype \synSigma_{x \oftype A} B(x) \types \textsf{split}_d (z) : C(z)}
\and
  \inferrule*[right=$\synSigma$-\comp]{\Gamma,\ z \oftype \synSigma_{x \oftype A} B(x) \types C(z)\myType \\ \Gamma,\ x \oftype A,\ y \oftype B(x) \types d(x,y) : C(\textsf{pair}(x, y))}{\Gamma,\ x \oftype A,\ y \oftype B(x) \types \textsf{split}_d (\textsf{pair} (x,y))=d(x,y) : C(\textsf{pair} (x, y))}
\end{mathparpagebreakable}

Again,  the special case where $B$ does not depend on $x$ is of particular interest: this gives the cartesian product $A \times B := \synSigma_{x \oftype A} B$. \\

\paragraph*{$\synId$-types.}  (Identity types, equality types.)

\begin{mathparpagebreakable}
  \inferrule*[right=$\synId$-\form]{\Gamma \types A\myType}{\Gamma,\ x,y\oftype A \types \synId_A(x,y)\myType}
\and
  \inferrule*[right=$\synId$-\intro]{\Gamma \types A\myType}{\Gamma,\ x\oftype A \types \myRefl_A(x):\synId_A(x,x)}
\and
  \inferrule*[right=$\synId$-\elim]{\Gamma,\ x,y\oftype A,\ u\oftype \synId_A(x,y) \types C(x,y,u)\myType \\ \Gamma,\ z\oftype A \types d(z):C(z,z,\myRefl_A(z))}{\Gamma,\ x,y\oftype A,\ u\oftype \synId_A(x,y) \types J_{z. d}(x,y,u) : C(x,y,u)}
\and
  \inferrule*[right=$\synId$-\comp]{\Gamma,\ x,y\oftype A,\ u\oftype \synId_A(x,y) \types C(x,y,u)\myType \\ \Gamma,\ z\oftype A \types d(z):C(z,z,r(z))}{\Gamma,\ x\oftype A \types J_{z.d}(x,x,\myRefl_A(x)) = d(x) : C(x,x,\myRefl_A(x))}
\end{mathparpagebreakable}

\paragraph*{$\synW$-types.}  (Types of well-founded trees; free term algebras.)

\begin{mathparpagebreakable}
  \inferrule*[right=$\synW$-\form]{\Gamma,\ x \oftype A \types B(x)\myType}{\Gamma \types \synW_{x \oftype A} B(x)\myType}
\and
  \inferrule*[right=$\synW$-\intro]{\Gamma,\ x \oftype A \types B(x)\myType}{\Gamma, \ x \oftype A, \ y \oftype [B(x), \synW_{u \oftype A} B(u)] \types \synsup(x, y) : \synW_{u \oftype A} B(u)}
\\
  \mathclap{\inferrule*[right=$\synW$-\elim]
    {\Gamma, \ w \oftype \synW_{x \oftype A} B(x) \types C(w) \myType \\
     \Gamma,\ x \oftype A,\ y \oftype [B(x), \synW_{u \oftype A} B(u)],\ z \oftype \synPi_{u \oftype B(x)} C(\mathsf{app}(y, u)) \hspace{1.55cm} \\
     \hspace{6cm} \types d(x, y, z) : C(\synsup(x, y))}
  {\Gamma,\ w \oftype \synW_{x \oftype A} B(x) \types \textsf{wrec}_{d} (w) : C(w)}}
\\
  \mathclap{\inferrule*[right=$\synW$-\comp]
  {\Gamma, \ w \oftype \synW_{x \oftype A} B(x) \types C(w) \myType \\
   \Gamma,\ x \oftype A,\ y \oftype [B(x), \synW_{u \oftype A} B(u)],\ z \oftype \synPi_{u \oftype B(x)} C(\mathsf{app}(y, u)) \hspace{2cm} \\
    \hspace{6.45cm} \types d(x, y, z) : C(\synsup(x, y))}
  {\Gamma, \ x \oftype A, \ y \oftype [B(x), \synW_{u \oftype A} B(u)] \types \textsf{wrec}_{d} (\synsup(x, y)) \hspace{2.8cm} \\
    \hspace{2.4cm} = d(x, y, \lambda u \oftype B(x). \mathsf{wrec}_d(\mathsf{app}(y, u))): C(\synsup(x, y))}}
\end{mathparpagebreakable}

\paragraph*{$\mathsf{0}$}  (Empty type.)

\begin{mathparpagebreakable}
  \inferrule*[right=${\sf 0}$-\form]{\textit{}}{\types {\sf 0}\myType}
\and
  \text{(No introduction rules.)}
\and
  \inferrule*[right=${\sf 0}$-\elim]{\Gamma, \ x \oftype {\sf 0} \types C(x)\myType}{\Gamma, \ x \oftype {\sf 0} \ \types \textsf{case} (x) : C(x)}
\and
  \text{(No computation rules.)}
\end{mathparpagebreakable}

\paragraph*{$\mathsf{1}$}  (Unit type, singleton type.)

\begin{mathparpagebreakable}
  \inferrule*[right=${\sf 1}$-\form]{\ }{\types {\sf 1} \myType}
\and
  \inferrule*[right=${\sf 1}$-\intro]{\ }{\types * : {\sf 1}}
\and
  \inferrule*[right=${\sf 1}$-\elim]{\Gamma,\ x \oftype {\sf 1} \types C(x)\myType \\ \Gamma \types d : C(*)}{\Gamma,\ x \oftype {\sf 1} \types \textsf{rec}_d (x) : C(x)}
\and
  \inferrule*[right=${\sf 1}$-\comp]{\Gamma,\ x \oftype {\sf 1} \types C(x)\myType \\ \Gamma \types d : C(*)}{\Gamma \types \textsf{rec}_d (*) = d : C(*)}
\end{mathparpagebreakable}

\paragraph*{$+$-types} (Binary disjoint sums.)

\begin{mathparpagebreakable}
  \inferrule*[right=$+$-\form]{\Gamma \types A\myType \\ \Gamma \types B\myType}{\Gamma \types A + B \myType}
\and
  \inferrule*[right=$+$-\intro\ 1.]{\Gamma \types A\myType \\ \Gamma \types B\myType}{\Gamma,\ x \oftype A \types \textsf{inl}(x) : A+ B}
\and
  \inferrule*[right=$+$-\intro\ 2.]{\Gamma \types A\myType \\ \Gamma \types B\myType}{\Gamma,\ y \oftype B \types \textsf{inr}(y) : A +B}
\and
  \inferrule*[right=$+$-\elim]{\Gamma,\ z \oftype A + B \types C(z)\myType \\ \Gamma,\ x \oftype A \types d_0(x) : C(\textsf{inl} (x)) \\ \Gamma,\ y \oftype B \types d_1(y) : C(\textsf{inr} (y))}{\Gamma,\ z \oftype A + B \types \textsf{case}_{d_0,d_1}(z) : C(z)}
\and
  \inferrule*[right=$+$-\comp\ 1.]{\Gamma,\ z \oftype A + B \types C(z)\myType \\ \Gamma,\ x \oftype A \types d_0(x) : C(\textsf{inl} (x)) \\ \Gamma,\ y \oftype B \types d_1(y) : C(\textsf{inr} (y))}{\Gamma,\ x \oftype A \types \textsf{case}_{d_0, d_1}(\textsf{inl}(x))=d_0(x) : C(\textsf{inl}(x))}
\and
  \inferrule*[right=$+$-\comp\ 2.]{\Gamma,\ z \oftype A + B \types C(z)\myType \\ \Gamma,\ x \oftype A \types d_0(x) : C(\textsf{inl} (x)) \\ \Gamma,\ y \oftype B \types d_1(y) : C(\textsf{inr} (y))}{\Gamma,\ y \oftype B \types \textsf{case}_{d_0, d_1}(\textsf{inr}(y))=d_1(y) : C(\textsf{inr}(y))}
\end{mathparpagebreakable}

\subsection*{Universes} \label{subsec:universe-rules}

A universe within the theory may be closed under some or all of the logical constructors of the theory; we include below the rules corresponding to all of the constructors given above.

\begin{mathparpagebreakable}
  \inferrule{ }{\types \synU\myType}
\and
  \inferrule{ }{\Gamma,\ x \oftype \synU \types \el (x) \myType}
\\
  \inferrule{\Gamma \types a : \synU \\ \Gamma,\ x \oftype \el(a) \types b(x) : \synU}{\Gamma \types \synpi (a, x. b(x)) : \synU}
\and
  \inferrule{\Gamma \types a : \synU \\ \Gamma,\ x \oftype \el(a) \types b(x) : \synU}{\Gamma \types \el (\synpi (a, x. b(x)) = \synPi_{x : \el(a)} \el(b(x)) \myType}
\\
  \inferrule{\Gamma \types a : \synU \\ \Gamma,\ x \oftype \el(a) \types b(x) : \synU}{ \Gamma \types \synsigma (a, x. b(x)) : \synU}
\and
  \inferrule{ \Gamma \types a : \synU \\ \Gamma,\ x \oftype \el(a) \types b(x) : \synU}{ \Gamma \types \el (\synsigma (a, x. b(x)) = \synSigma_{x : \el(a)} \el(b(x)) \myType}
\\
  \inferrule{\Gamma \types a, b : \synU}{ \Gamma \types a + b : \synU}
\and
  \inferrule{ \Gamma \types a, b : \synU}{ \Gamma \types \el (a + b) = \el (a) + \el (b) \myType}
\\
  \inferrule{ \Gamma \types a : \synU \\ \Gamma \types b, c : \el (a)}{ \Gamma \types \synid_A (b,c) : \synU}
\and
  \inferrule{ \Gamma \types a : \synU \\  \Gamma \types b, c : \el (a)}{ \Gamma \types \el (\synid_a(b,c)) = \synId_{\el (a)}(b, c) \myType}
\\
  \inferrule{ }{\types \synz : \synU}
\and
  \inferrule{ }{\types \el (\synz) = \mathsf{0} \myType}
\and
  \inferrule{ }{\types \syno : \synU}
\and
  \inferrule{ }{\types \el (\syno) = \mathsf{1} \myType}
\\
  \inferrule{ \Gamma \types a : \synU \\  \Gamma ,\ x \oftype \el(a) \types b(x) : \synU}{ \Gamma \types \synw (a, x. b(x)) : \synU}
\and
  \inferrule{ \Gamma \types a : \synU \\  \Gamma ,\ x \oftype \el(a) \types b(x) : \synU}{ \Gamma \types \el (\synw (a, x. b(x)) = \synW_{x : \el(a)} \el(b(x)) \myType}
\end{mathparpagebreakable}

\subsection*{Further rules} \label{subsec:optional-rules}

The rules above are somewhat weak in their treatment of the equality of functions.  To this end, some further rules are often adopted: the \emph{$\eta$-rule} for $\synPi$-types, and the \emph{functional extensionality} rule(s).  Our formulation of the latter is taken from \cite{garner:depprod}; see also \cite{hofmann:thesis}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\synPi$-$\eta$]
    {\Gamma \types f : \synPi_{x \oftype A} B(x)}
    {\Gamma \types \eta(f) : f = \lambda x \oftype A. \syn{app}(f,x) : \synPi_{x \oftype A} B(x) }
\and
  \inferrule*[right=$\synPi$-ext]
    {\Gamma \types f, g : \synPi_{x \oftype A} B(x) \\
     \Gamma \types h : \synPi_{x \oftype A} \synId_{B(x)}(\syn{app}(f,x),\syn{app}(g,x)) }
    {\Gamma \types \syn{ext}(f,g,h) : \synId_{\synPi_{x \oftype A} B(x)}(f,g) }
\and
  \inferrule*[right=$\synPi$-ext-comp-prop]
    {\Gamma, x \oftype A \types b : B(x) }
    {\Gamma \types \syn{ext\text{-}comp}(x.b): \synId_{\synPi_{x \oftype A} B(x)} \hspace{4.4cm}  \\
     \hspace{2cm} (\syn{ext}(\lambda x \oftype A. b,\lambda x \oftype A. b,\lambda x \oftype A. \myRefl b), \myRefl (\lambda x \oftype A. b)) }
\end{mathparpagebreakable}

\egroup

\section{Algorithmic and semantic issues}

\message{Thierry and Peter can now start re-writing this section.  The
  following text is old.}

\subsection*{Conversion and reduction}

Together with $\beta$-conversion
\[
  (\lam{x} t)(u) \defeq t[u/x]
\]
and thinking of $\defeq$ as a rewriting rule (unfolding definitions),
this forms a rewriting system which has the confluence (or Church-Rosser) property: we can
define $t \conv u$ to mean that $t$ and $u$ can be reduced to the same term by using
$\beta$-reduction and recursion.


\subsection*{Some Syntactical Properties of the Type Theory}
 This system has the following syntactical properties.

\begin{thm}\label{red}
If $A : \UU$ and $A \conv A'$ then $A' : \UU$.
If $t:A$ and $t \conv t'$ then $t':A$.
\end{thm}

\begin{thm}\label{SN}
 If $A : \UU$ then $A$ is strongly normalizable.
If $t:A$ then $A$ and $t$ are strongly normalizable. % note: ``strongly normalizable'' is undefined
\end{thm}

We say that a term is {\em in normal form} if it cannot be reduced.  A closed
normal type has to be a primitive type, i.e., to be of the form $c(\vec{v})$
for some primitive constant $c$ (where $\vec{v}$ may be omitted if empty, for
instance, as with $\N$).  More generally we have the following explicit
description of terms in normal form.

\begin{lem}\label{normal}
The terms in normal form can be described by the following syntax
\begin{align*}
 v & \production  k \mid \lam{x} v \mid c(\vec{v}) \mid f(\vec{v}) \\
 k &\production x \mid k(v) \mid f(\vec{v})(k)
\end{align*}
where $f(\vec{v})$ represents a partial application of the defined function $f$.
In particular, a type in normal form is of the form $k$ or $c(\vec{v})$.
\end{lem}

\begin{thm}
If $A$ is in normal form then the 
judgment $A : \UU$ is decidable. If $A : \UU$ and $t$ is in normal form then the judgment
$t:A$ is decidable.
\end{thm}


 A corollary is the {\em consistency} property: there is no proof of $\emptyt$ in the empty
context. Indeed if we have $t:\emptyt$ then by Theorems \ref{red} and \ref{SN} the term $t$ will reduce
to a term in normal form $t'$ that satisfies $t':\emptyt$, but this is not possible by a 
purely combinatorial argument using Lemma \ref{normal}. Similarly, we have the following
{\em canonicity} property: if $t:N$ in the empty context, then $t$ has to reduce to a
normal form $\suc^k(0)$ for some numeral $k$. Finally, it means that, if we restrict to terms
in normal form, the typing relation is {\em decidable}, and identifying type-checking with
{\em proof-checking}, we can indeed ``recognize a proof of an assertion when we see one''.

\section*{Notes}\label{subsec:general-remarks}

  %This presentation is strongly inspired by two  Martin-L\"of 1972 and 1973.

  The system of rules with introduction (primitive constants) and elimination
  and computation rules (defined constant) is inspired by Gentzen natural
  deduction. The possibility of strengthening the elimination rule for
  existential quantification was indicated in \cite{Howard-1969}. The
  strengthening of the axioms for disjunction appears in \cite{Martin-Lof-1972},
  and for absurdity elimination and identity type in \cite{Martin-Lof-1973}. The
  $W$-types were introduced in \cite{Martin-Lof-1979}. They generalize a notion
  of trees introduced by \cite{Tait-1968}.
  %inspired from unpublished work of Spector.

  The generalized form of primitive recursion for natural numbers and ordinals
  appear in \cite{Hilbert-1925}.  This motivated G\"odel's system $T$,
  \cite{Goedel-T-1958}, which was analyzed by \cite{Tait-1966}, who used,
  following \cite{Goedel-1958}, the terminology ``definitional equality'' for
  conversion: two terms are {\em definitionally equal} if they reduce to a
  common term by means of a sequence of applications of the reduction
  rules. This terminology was also used by de Bruijn \cite{deBruijn-1973} in his
  presentation of {\em Automath}.

  Streicher \cite[Theorem 4.13]{Streicher-1991}, explains how to give the
  semantics in contextual category of terms in normal form using a simple syntax
  similar to the one we have presented.

\egroup

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
