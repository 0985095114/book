\chapter{The Rules of Type Theory}
\bgroup                         % restrict the scope of our macros to this file

\newcommand{\production}{\vcentcolon\vcentcolon=}

\newcommand{\mkbox}[1]{\ensuremath{#1}}

\newcommand{\app}{\mathsf{app}}

\newcommand{\gothic}{\mathfrak}
\newcommand{\gP}{{\gothic p}}
\newcommand{\gM}{{\gothic M}}
\newcommand{\gN}{{\gothic N}}
\newcommand{\rats}{\mathbb{Q}}
\newcommand{\ints}{\mathbb{Z}}

\newcommand{\lbr}{\lbrack\!\lbrack}
\newcommand{\rbr}{\rbrack\!\rbrack}
\newcommand{\sem}[2] {\lbr #1 \rbr_{#2}}  % interpretation of the terms
\newcommand{\APP}[2] {{\sf app}(#1,#2)}  % interpretation of the terms
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Con}{{\sf Con}}
\newcommand{\Elem}{{\sf Elem}}
\newcommand{\myId}{1}
\newcommand{\mypp}{{\sf p}}
\newcommand{\qq}{{\sf q}}
\newcommand{\mySp}{{\sf Sp}}
\newcommand{\conv}{~{\sf conv}~}
\newcommand{\SUP}{{\sf sup}}
\newcommand{\PAIR}{{\sf pair}}
\newcommand{\WW}{{\sf W}}       % phase out in favor of $\wtype{a:A} B(a)$
\newcommand{\LIM}{{\sf lim}}
\newcommand{\nn}{{\sf n}}
\newcommand{\myzero}{{\sf 0}}
\newcommand{\Fam}{{\sf Fam}}

The goal of this appendix is to summarize the notation and inference rules of
the type theory used in this book.

\section{Syntax, informally}

\subsection*{The Raw Syntax}

The objects and types of our type theory may be written as {\em terms} or {\em
  expressions} using the following syntax, which is an extension of
$\lambda$-calculus with {\em variables} $x, x',\dots$, {\em primitive}
constants $c,c',\dots$, {\em defined} constants $f,f',\dots$, and term forming
operations
\[
  t \production x \mid \lam{x} t \mid t(t') \mid c \mid f
\]

We follow the usual convention about free and bound variables.  We write
$B[a/x]$ for the substitution of a term $a$ for free occurrences of the
variable $x$ in the expressions $B$, with possible renaming for avoiding
capture of variables, as discussed in \autoref{sec:function-types}.
Alternatively, we may regard $B$ as an {\em abstraction}, which signifies that
a variable, $x$, say, is bound within $B$ and can be renamed without changing
the identity of $B$.  In that case, we'll let $B[a]$ denote the result of
substituting $a$ for the (outermost) variable bound in $B$ and removing the
abstraction that recorded its presence and its name.  We use $B[a_1,\dots,a_n]$
as an abbreviation for the repeated substitution $B[a_1]\dots[a_n]$.

We use $t(t_1,\dots,t_n)$ as an abbreviation for the repeated application
$t(t_1)(t_2)\dots (t_n)$.  We may also use {\em infix} notation, writing $t_1\;
\star\; t_2$ for $\star(t_1,t_2)$ when $\star$ is a primitive or defined
constant.

Each defined constant will have zero, one or more {\em defining equations}.
There will be two kinds of defined constant.  An {\em explicit} defined
constant $f$ will have a single defining equation
  \[ f(x_1,\dots,x_n)\defeq t,\]
where $t$ does not involve $f$.  An example of explicit definition will be displayed later.  We introduce the explicit defined constant 
$\circ$, for composition of functions, with defining equation
  \[ \circ (x,y)(z) \defeq x(y(z))\]
and use infix notation $x\circ y$ for $\circ(x,y)$.



The second kind of defined constant will be used in connection with a form of type having some primitive constants that are used to introduce elements into types of that form.  With each such primitive constant $c$ there will be a defining equation of the form
\[
  f(x_1,\dots,x_n,c(y_1,\dots,y_m)) \defeq t,
\]
where now $f$ may occur in $t$, but now only in such a way that, in the context
where $f$ is introduced it will be a totally defined typed function.  The
paradigm examples of such defined functions are the functions defined by
primitive recursion on the natural numbers.  We may call this kind of
definition of a function a {\em total recursive definition}.  In computer
science and logic this kind of definition of a function on a recursive data
type has been called a {\em definition by structural recursion}.

We introduce definitional equality $t \jdeq t'$ between terms $t$ and $t'$ as
the equivalence relation generated by all instances of {\em definition
  unfolding}:
\[
  (\lam{x} t)(u) \jdeq t[u/x].
\]

\subsection*{The forms of judgment}

In type theory, we mainly derive assertions or judgments of the form $A : \UU_i$
(which means ``$A$ is a correct type'') or $a:A$ (which means ``$a$ is a
correct term of type $A$'').  It will also be useful to have judgments of the
form $B~\Fam(A)$, which means ``$B$ is a correct family of types, $B(x)$ for
$x:A$''.  The judgment $A=B : \UU$ is defined to mean $A : \UU$, $B : \UU$ and
$A\conv B$ while the judgment $t=u:A$ is defined to mean $t:A$, $u:A$ and $t\conv
u$.  In general these assertions are done inside a {\em context} (or ``space of
parameters''), which is of the form
\[
  \Gamma =  x_1:A_1, x_2:A_2,\dots,x_n:A_n
\]
and we write, for example, $A : \UU(\Gamma)$ and $a:A(\Gamma)$. 

 We write simply $A : \UU$ and $a:A$ if the context is empty, or if the context
can be omitted without ambiguity.

 If $x_1:A_1,x_2:A_2,\dots,x_n:A_n$ is a context, this means that we have
derived $A_1 : \UU$ and then $A_2 : \UU(x_1:A_1)$, and $A_3 : \UU(x_1:A_1,x_2:A_2)$
$\dots$

If $J$ is a judgment, we may write $J[a/x]$ for the judgment obtained by
substitution of $a$ for free occurrences of the variable $x$ in $J$.

\medskip

\subsection*{The Rules of a Basic Type Theory}
Here we give rules for the following basic type constructions:
$ \prd{a:A}B$; $ \N$; $ \emptyt$; $ \unit$; $ \bool$; $ \Sigma(A, B)$; $ A_1+A_2$; $ \wtype{a:A} B$; and $Id(A, a, a')$.
We write $A\rightarrow B$ instead of $\prd{a:A}B$ if $x$ is not free in $B$.

\medskip

\subsection*{The General and $\Pi$ Rules}
 The basic general rules of type theory are 
\begin{itemize}
\item if $B : \UU(x:A)$ then $\lam{x} B\Fam(A)$
\item if $B\Fam(A)$ then 
\begin{itemize}
\item if $a:A$ then $B(a) : \UU$,
\item $\prd{a:A}B : \UU$,
\item if $b:B(x)(x:A)$ then $\lam{x} b:\prd{a:A}B$, and
\item if $c:\prd{a:A}B$ and $a:A$ then $c(a):B(a)$
\end{itemize}
\item if $a:A$ and $A= B$ then $a:B$
\end{itemize}

\medskip

 When writing rules we follow the convention that we don't write explicitly the whole context.  For instance, the more explicit rule for abstraction should be: if $b:B(x)(\Gamma,x:A)$ then $\lam{x} b:\prd{a:A}B(\Gamma)$.

\medskip

We now present the basic forms of primitive type.  

\subsection*{The Type of Natural Numbers}
We start with
the type of natural numbers, which  is obtained by adding primitive constants
$\N,\myzero,\suc$ with the following rules.
\begin{itemize}
\item $\N : \UU$,
\item $\myzero:\N$,
\item $\suc:\N\rightarrow \N$.
\end{itemize}

 Furthermore, we can define functions by primitive recursion.  If we have
$C\Fam(\N)$ we can introduce $f:\prd{n:\N}C(n)$ whenever we have
\[
  d:C(\myzero)~~~~~~e:\prd{x:\N}(C(x)\rightarrow C(\suc (x)))
\]
with the defining equations
\[
  f(\myzero) \defeq d~~~~~~~~~~~~f(\suc (x)) \defeq e(x,f(x))
\]
 
As usual $C,d,e$ may have been obtained in an implicit context $\Gamma$ in which variables $x_1,\ldots,x_n$ are declared.  Then there will be the extra implicit parameters $x_1,\ldots,x_n$, so that the fully explicit primitive recursion schema is
\[
  f(x_1,\dots,x_n)(\myzero) \defeq d[x_1,\dots,x_n]~~~~~~~~f(x_1,\dots,x_n)(\suc (x)) \defeq e[x_1,\dots,x_n,x,f(x_1,\dots,x_n)(x)]
\]

\medskip
\subsection*{The Finite Types $\emptyt,\unit,\bool$}

We introduce primitive constants $0,1,\emptyt,\unit,\bool$ are introduced as primitive constants with the rules

\begin{itemize}
\item $\emptyt : \UU_0$, $\unit : \UU_0$, $\bool : \UU_0$,
\item $\ttt:\unit$, $\bfalse:\bool$, $\btrue:\bool$.
\end{itemize}
 For $k=0,1,2$, if we have $C\Fam(\N_k)$ we can introduce $f:\Pi(\N_k,C)$.
\begin{itemize}
\item When $k=0$ $f$ has no defining equation.  
\item When $k=1$, if $c_0:C(0)$ then $f$ has the defining equation
  \[ f(0)\defeq c_0.\]
\item When $k=2$, if $c_0:C(0)$ and $c_1:C(1)$ then $f$ has the defining equations
  \[ f(0)\defeq c_0\mbox{ and } f(1)\defeq c_1.\]
\end{itemize}

\subsection*{$\Sigma$-Types}
For $\Sigma$-types we introduce primitive constants $\Sigma$ and $\PAIR$ with the rules
\begin{itemize}
\item if $B\Fam(A)$ then $\Sigma(A,B) : \UU$, and
\item if $a:A$ and $b:B(a)$ then $\PAIR(a,b):\Sigma(A,B)$.
\end{itemize}
We write $(\Sigma x:A)B$ instead
of $\Sigma(A,\lam{x} B)$ and we write $A\times B$ instead of $(\Sigma x:A)B$ if
$x$ is not free in $B$.  If we have $C\Fam(\Sigma(A,B))$ and
$
d:(\Pi x:A)(\Pi y:B(x))C(\PAIR(x,y))
$
we can introduce $f:\Pi(\Sigma(A,B),C)$ with the defining equation
\[
  f(\PAIR(x,y))\defeq d(x,y).
\]

\medskip

\subsection*{Binary Sum Types $A_1+A_2$}
We introduce primitive constants $+,in_1,in_2$ with the rules
\begin{itemize}
\item if $A_1,A_2 : \UU$ then $+(A_1,A_2) : \UU$, and
\item if $a:A_i$ then $in_i(a):A_i$, for $i=1,2$.
\end{itemize}
We write $A_1+A_2$ instead of $+(A_1,A_2)$.
If $C\Fam(A_1+A_2)$ and $d_i:\Pi(A_i,C\circ in_i)$ for $i=1,2$,
then we can introduce a defined constant $f:\Pi(A_1+A_2,C)$ with the defining equations
  \[ f(in_i(x))\defeq d_i(x)\mbox{ for } i=1,2.\]

\subsection*{$W$-Types}
For $W$-types we introduce primitive constants $\WW$ and $\SUP$ with the rules
\begin{itemize}
\item if $B\Fam(A)$ then $\WW(A,B) : \UU$, and
\item if $a:A$ and $u:B(a)\rightarrow \WW(A,B)$ then $\SUP(a,u):\WW(A,B)$.
\end{itemize}
 
 Here also we can define functions by total recursion. If we have
$C\Fam(\WW(A,B))$ we can introduce $f:(\Pi z:\WW(A,B))C(z)$ whenever we have
\[
  d:(\Pi x:A)(\Pi u:B(x)\rightarrow \WW(A,B))((\Pi y:B)C(u(y)))\rightarrow C(\SUP(x,u))
\]
with the defining equation
\[
  f(\SUP(x,u)) \defeq d(x,u,f\circ u)
\]
where $(f\circ u)(y) \defeq f(u(y))$.

\subsection*{Identity Types $Id_A(a,a')$}
We introduce primitive constants $Id$ and $\refl{}$ with the rules
\begin{itemize}
\item if $A : \UU$ and $a:A$ then $Id(A,a)\Fam(A)$, and
\item if $a:A$ then $\refl{a}:Id(A,a)(a)$.
\end{itemize}
If $C : \UU(y:A,z:Id(A,a,y))$ and $d:C[a,\refl{a}]$ then we can introduce a defined constant 
\[
  f:(\Pi y:A)(\Pi z:Id(A,a))C
\]
with defining equation
  \[ f(a,\refl{a})\defeq d.\]
When we make explicit a variable declaration $x:A$ 
and let $a$ be $x$ 
so that we have 
\[
  C : \UU(x,y:A, z:Id(A,x,y))\mbox{ and  }d:(\Pi x:A)C[x,x,\refl{x}]
\]
then we have the defined constant
\[
  f':(\Pi x,y:A)(\Pi z:Id(A,x,y))C
\]
with defining equation
\[
  f'(x,x,\refl{x})\defeq d(x).
\]
This defined constant $f'$, with its defining equation, corresponds to the rules for identity types originally formulated by Per Martin-L\"{o}f.   The defined constant $f$, with its defining equation, corresponds to the rules given later by Christine Paulin-Mohring.  It is not entirely trivial to recapture $f$ from $f'$.


\subsection*{Type Universes}

 A type theory can be extended by introducing a type universe $\UU$ with rules that ``reflect'' the forms of type previously considered, here the forms of type of the basic type theory.  The general rules for $\UU$ are

\begin{itemize}
\item $\UU : \UU$, and
\item $A : \UU$ if $A:\UU$.
\end{itemize}

The rules reflecting the forms of type of the basic type theory are

\begin{itemize}
\item $\N,\emptyt,\unit,\bool:\UU$,
\item if $A_1,A_2:\UU$ then $A_1+A_2:\UU$,
\item if $A:\UU$ and $B:A\rightarrow\UU$ then     $\Pi(A,B),\Sigma(A,B),\WW(A,B):\UU$, and 
\item if $A:\UU$ and $a,a':A$ then $Id(A,a,a'):\UU$.
\end{itemize}

Having added the type universe $\UU$ we may introduce another type universe
$\UU^+$ that has all the previous rules that $\UU$ has, but in addition reflects the above two general rules of $\UU$; i.e., it has the rules

\medskip

\begin{itemize}
\item $\UU:\UU^+$, and
\item $A:\UU^+$ if $A:\UU$.
\end{itemize}

\medskip

Iterating we get an infinite hierarchy of universes $\UU_0,\UU_1,\ldots$, where
$\UU_0=\UU$ and $\UU_{n+1}=\UU_n^+$ for $n=0,1,\ldots$.  They share the reflection rules
stated above for $\UU$:

\begin{itemize}
\item if $A_1,A_2:\UU_n$ then $A_1+A_2:\UU_n$,
\item if $A:\UU_n$ and $B:A\rightarrow\UU_n$ then     $\Pi(A,B),\Sigma(A,B),\WW(A,B):\UU_n$, and 
\item if $A:\UU_n$ and $a,a':A$ then $Id(A,a,a'):\UU_n$.
\end{itemize}


\section{Syntax, more formally}

(In this section, we'll import the rules of \cite{klv:ssetmodel}, converted to Russell-style
universes.  We'll add a few remarks about Tarski-style universes.)

\section{Algorithmic and semantic issues}

(Thierry and Peter will start writing this section after I get all the macros
converted to book-standard macros.)

\subsection*{Conversion and reduction}

Together with $\beta$-conversion
\[
  (\lam{x} t)(u) \defeq t[u/x]
\]
and thinking of $\defeq$ as a rewriting rule (unfolding definitions),
this forms a rewriting system which has the confluence (or Church-Rosser) property: we can
define $t \conv u$ to mean that $t$ and $u$ can be reduced to the same term by using
$\beta$-reduction and recursion.


\subsection*{Some Syntactical Properties of the Type Theory}
 This system has the following syntactical properties.

\begin{thm}\label{red}
If $A : \UU$ and $A \conv A'$ then $A' : \UU$.
If $t:A$ and $t \conv t'$ then $t':A$.
\end{thm}

\begin{thm}\label{SN}
 If $A : \UU$ then $A$ is strongly normalizable.
If $t:A$ then $A$ and $t$ are strongly normalizable. 
\end{thm}

\message{Warning: TODO: Insert somewhere the definition of strongly normalizable.}

We say that a term is {\em in normal form} if it cannot be reduced.  A closed
normal type has to be a primitive type, i.e., to be of the form $c(\vec{v})$
for some primitive constant $c$ (where $\vec{v}$ may be omitted if empty, for
instance, as with $\N$).  More generally we have the following explicit
description of terms in normal form.

\begin{lem}\label{normal}
The terms in normal form can be described by the following syntax
\begin{align*}
 v & \production  k \mid \lam{x} v \mid c(\vec{v}) \mid f(\vec{v}) \\
 k &\production x \mid k(v) \mid f(\vec{v})(k)
\end{align*}
where $f(\vec{v})$ represents a partial application of the defined function $f$.
In particular, a type in normal form is of the form $k$ or $c(\vec{v})$.
\end{lem}

\begin{thm}
If $A$ is in normal form then the 
judgment $A : \UU$ is decidable. If $A : \UU$ and $t$ is in normal form then the judgment
$t:A$ is decidable.
\end{thm}


 A corollary is the {\em consistency} property: there is no proof of $\emptyt$ in the empty
context. Indeed if we have $t:\emptyt$ then by Theorems \ref{red} and \ref{SN} the term $t$ will reduce
to a term in normal form $t'$ that satisfies $t':\emptyt$, but this is not possible by a 
purely combinatorial argument using Lemma \ref{normal}. Similarly, we have the following
{\em canonicity} property: if $t:N$ in the empty context, then $t$ has to reduce to a
normal form $\suc^k(0)$ for some numeral $k$. Finally, it means that, if we restrict to terms
in normal form, the typing relation is {\em decidable}, and identifying type-checking with
{\em proof-checking}, we can indeed ``recognize a proof of an assertion when we see one''.

\section*{Notes}\label{subsec:general-remarks}

  %This presentation is strongly inspired by two  Martin-L\"of 1972 and 1973.

  The system of rules with introduction (primitive constants) and elimination
  and computation rules (defined constant) is inspired by Gentzen natural
  deduction. The possibility of strengthening the elimination rule for
  existential quantification was indicated in \cite{Howard-1969}. The
  strengthening of the axioms for disjunction appears in \cite{Martin-Lof-1972},
  and for absurdity elimination and identity type in \cite{Martin-Lof-1973}. The
  $W$-types were introduced in \cite{Martin-Lof-1979}. They generalize a notion
  of trees introduced by \cite{Tait-1968}.
  %inspired from unpublished work of Spector.

  The generalized form of primitive recursion for natural numbers and ordinals
  appear in \cite{Hilbert-1925}.  This motivated G\"odel's system $T$,
  \cite{Goedel-T-1958}, which was analyzed by \cite{Tait-1966}, who used,
  following \cite{Goedel-1958}, the terminology ``definitional equality'' for
  conversion: two terms are {\em definitionally equal} if they reduce to a
  common term by means of a sequence of applications of the reduction
  rules. This terminology was also used by de Bruijn \cite{deBruijn-1973} in his
  presentation of {\em Automath}.

  Streicher \cite[Theorem 4.13]{Streicher-1991}, explains how to give the
  semantics in contextual category of terms in normal form using a simple syntax
  similar to the one we have presented.

\egroup

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
