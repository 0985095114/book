% !TeX root = main.tex

\titleformat{\chapter}[display]{\fontsize{23}{25}\fontseries{m}\fontshape{it}\selectfont}{\chaptertitlename}{20pt}{\fontsize{35}{35}\fontseries{b}\fontshape{rm}\selectfont}
\chapter{The rules of type theory}
\label{cha:rules}

\newcommand{\emptyctx}{\ensuremath{\cdot}}
\newcommand{\production}{\vcentcolon\vcentcolon=}
\newcommand{\conv}{\sim}
\newcommand{\ctx}{\ensuremath{\mathsf{ctx}}}
\newcommand{\wfctx}[1]{\vdash #1\ \ctx}
\newcommand{\oftp}[3]{#1 \vdash #2 : #3}
\newcommand{\jdeqtp}[4]{#1 \vdash #2 \jdeq #3 : #4}
\newcommand{\judg}[2]{#1 \vdash #2}
\newcommand{\tmtp}[2]{#1 \mathord{:} #2}

% rule names
\newcommand{\form}{\textsc{form}}
\newcommand{\intro}{\textsc{intro}}
\newcommand{\elim}{\textsc{elim}}
\newcommand{\comp}{\textsc{comp}}
\newcommand{\Weak}{\mathsf{Wkg}}
\newcommand{\Vble}{\mathsf{Vble}}
\newcommand{\Exch}{\mathsf{Exch}}
\newcommand{\Subst}{\mathsf{Subst}}

Just as one can practice traditional mathematics without a precise understanding
of the axioms of Zermelo--Fraenkel set theory, in this book we have developed
mathematics in univalent foundations without yet precisely describing the formal
system of homotopy type theory. Nevertheless, it is important to \emph{have} a
precise description of HoTT in order to, for example,
%
\begin{itemize}
\item state and prove its metatheoretic properties, including logical
consistency (that $\emptyt$ has no elements);
\item construct models in simplicial sets, model categories, higher toposes,
etc.; or
\item implement it in proof assistants like Coq or Agda.
\end{itemize}

Even the logical consistency of HoTT is not obvious: if we had erroneously
chosen a definition of equivalence for which $\eqv{\emptyt}{\unit}$, then
univalence would imply that $\emptyt$ has an element, since $\unit$ does.
Nor is it obvious that, for example, our definition of $\Sn^1$ as a higher
inductive type yields a type which behaves like the ordinary circle.

There are two aspects of type theory which we must pin down before addressing
such questions. To show that there is no term $a$ for which we can derive
$a:\emptyt$, we must first define precisely our \emph{domain of discourse}---the
terms of type theory.  Then we must define precisely our \emph{rules of
inference}---what it means to derive the judgment $a:A$.%
\footnote{In propositional logic, the domain of discourse consists of logical
sentences built from atomic formulas and logical operators, while the rules of
inference are modus ponens, conjunction introduction, and so forth.}

In this appendix, we present two precise formulations of Martin-L\"{o}f type
theory, and of the extensions we have introduced for homotopy type theory. The
first presentation (\autoref{sec:syntax-informally}) describes our domain of
discourse as an extension of the untyped $\lambda$-calculus, while leaving the
rules of inference imprecise. The second (\autoref{sec:syntax-more-formally})
makes both precise using a natural deduction presentation, as is customary in
type-theoretic literature.

\section{Preliminaries}

In \autoref{cha:typetheory}, we presented the two basic \emph{judgments} of type
theory. The first, $a:A$, asserts that a term $a$ has type $A$.  The second,
$a\jdeq b:A$, states that the two terms $a$ and $b$ are \emph{judgmentally
equal} at type $A$. These judgments are inductively defined by a set of
inference rules described in \autoref{sec:syntax-more-formally}.

To construct an element $a$ of a type $A$ is to derive $a:A$; in the book, we
give informal arguments which describe the construction of $a$, but formally,
one must specify a precise term $a$ and a full derivation that $a:A$.

However, the main difference between the presentation of type theory in the book
and in this appendix is that, in this appendix, judgments are explicitly
formulated in an ambient \define{context}, or list of assumptions, of the form
\[
  x_1:A_1, x_2:A_2,\dots,x_n:A_n.
\]
An element $x_i : A_i$ of the context expresses the assumption that the
variable $x_i$ has type $A_i$. The variables $x_1, \ldots, x_n$ appearing in
the context must be distinct. We abbreviate contexts with the letters $\Gamma$
and $\Delta$.

The judgment $a:A$ in context $\Gamma$ is written 
\[ \oftp\Gamma aA \]
and means that $a:A$ under the assumptions listed in $\Gamma$. When the list of
assumptions is empty, we write simply
\[ \oftp{}aA \]
or
\[ \oftp\emptyctx aA \]
where $\emptyctx$ denotes the empty context. The same applies to the equality
judgment
\[
  \jdeqtp\Gamma{a}{b}{A}
\]

However, such judgments are sensible only for \define{well-formed} contexts, a
notion captured our third and final judgment
\[
  \wfctx{(x_1:A_1, x_2:A_2,\dots,x_n:A_n)}
\]
expressing that each $A_i$ is a valid type in the context $x_1:A_1,
x_2:A_2,\dots,x_{i-1}:A_{i-1}$. Therefore, if $\oftp\Gamma aA$ and
$\wfctx\Gamma$, then we know that each $A_i$ contains only the variables
$x_1,\dots,x_{i-1}$, and that $a$ and $A$ contain only the variables
$x_1,\dots,x_n$.

In informal mathematical presentations, the context is
implicit. At each point in a proof, the mathematician knows which
variables are available and what types they have, either by historical
convention ($n$ is usually a number, $f$ is a function, etc.) or
because variables are explicitly introduced with sentences such as
``let $x$ be a real number''. We discuss some benefits of using explicit
contexts in \autoref{sec:more-formal-pi,sec:more-formal-sigma}.

We write $B[a/x]$ for the \define{substitution} of a term $a$ for free occurrences of
the variable~$x$ in the term $B$, with possible capture-avoiding
renaming of bound variables, as discussed in
\autoref{sec:function-types}. The general form of substitution
%
\[
   B[a_1,\dots,a_n/x_1,\dots,x_n]
\]
%
substitutes expressions $a_1,\dots,a_n$ for the variables
$x_1,\dots,x_n$ simultaneously.

To \define{bind a variable $x$ in an expression $B$} means to incorporate both of
them into a larger expression, called an \define{abstraction}, whose
purpose is to express the fact that $x$ is ``local'' to $B$, i.e., it
is not to be confused with other occurrences of $x$ appearing
elsewhere. Bound variables are familiar to programmers, but less so to mathematicians.
Various notations are used for binding, such as $x \mapsto B$,
$\lam x B$, and $x \,.\, B$, depending on the situation.  We may write $C[a]$ for the
substitution of a term $a$ for the variable in the abstracted expression, i.e.,
we may define $(x.B)[a]$ to be $B[a/x]$.  As discussed in
\autoref{sec:function-types}, changing the name of a bound variable everywhere
within an expression does not change the expression. Thus, to be very
precise, an expression is an equivalence class of syntactic forms
which differ in names of bound variables.

One may also regard each variable $x_i$ of a judgment
\[
  x_1:A_1, x_2:A_2,\dots,x_n:A_n \vdash a : A
\]
to be bound in its \define{scope}, consisting of the expressions $A_{i+1},
\ldots, A_n$, $a$, and $A$.

\section{The first presentation}
\label{sec:syntax-informally}

The objects and types of our type theory may be written as terms using
the following syntax, which is an extension of $\lambda$-calculus with
\emph{variables} $x, x',\dots$, \emph{primitive} constants
$c,c',\dots$, \emph{defined} constants $f,f',\dots$, and term forming
operations
%
\[
  t \production x \mid \lam{x} t \mid t(t') \mid c \mid f
\]
%
The notation used here means that a term $t$ is either a variable $x$, or it
has the form $\lam{x} t$ where $x$ is a variable and $t$ is a term, or it has
the form $t(t')$ where $t$ and $t'$ are terms, or it is a primitive constant
$c$, or it is a defined constant $f$.  The syntactic markers '$\lambda$', '(',
')', and '.' are punctuation for guiding the human eye.

We use $t(t_1,\dots,t_n)$ as an abbreviation for the repeated application
$t(t_1)(t_2)\dots (t_n)$.  We may also use \emph{infix} notation, writing $t_1\;
\star\; t_2$ for $\star(t_1,t_2)$ when $\star$ is a primitive or defined
constant.

Each defined constant will have zero, one or more \emph{defining equations}.
There will be two kinds of defined constant.  An \emph{explicit} defined
constant $f$ will have a single defining equation
  \[ f(x_1,\dots,x_n)\defeq t,\]
where $t$ does not involve $f$.  

As an example, we introduce the explicit defined constant $\circ$, for
composition of functions, with defining equation
  \[ \circ (x,y)(z) \defeq x(y(z)),\]
and we use infix notation $x\circ y$ for $\circ(x,y)$.

The second kind of defined constant will be used in connection with a form of type having some primitive constants that are used to introduce elements into types of that form.  With each such primitive constant $c$ there will be a defining  equation of the form
\[
  f(x_1,\dots,x_n,c(y_1,\dots,y_m)) \defeq t,
\]
where $f$ may occur in $t$, but now only in such a way that, in the context
where $f$ is introduced it will be a totally defined typed function.  The
paradigm examples of such defined functions are the functions defined by
primitive recursion on the natural numbers.  We may call this kind of
definition of a function a \emph{total recursive definition}.  In computer
science and logic this kind of definition of a function on a recursive data
type has been called a \emph{definition by structural recursion}.

We introduce the notion of \emph{convertibility} $t \conv t'$ between terms $t$
and $t'$ as the congruence 
%equivalence 
relation generated by all instances of the $\beta$-conversion
defining equation for $\lambda$-abstraction %elementary reduction
%
\[
  (\lam{x} t)(u) \defeq t[u/x].
\]
%
and by all instances of the defining equations for the defined constants, 
such as the one for $x \circ y$
presented above, and by those to be introduced below.  Here, by a congruence 
relation on the terms of our syntax we mean an equivalence relation $\sim$ 
such that $t(s)\sim t'(s')$ whenever $t\sim t'$ and $s\sim s'$ and 
$\lam{x} t\sim \lam{x} t'$ whenever $t\sim t'$.

The equality judgments $t \jdeq u : A$ are derived by the following single rule.
%
\begin{itemize}
\item if $t:A$, $u:A$, and $t \conv u$, then $t \jdeq u : A$
\end{itemize}
%
Equality is an equivalence relation.

%% \begin{itemize}
%% \item if $t:A$, then $t \jdeq t : A$
%% \item if $t \jdeq u : A$, then $u \jdeq t : A$
%% \item if $t \jdeq u : A$ and $u \jdeq v : A$, then $t \jdeq v : A$
%% \end{itemize}

\subsection{Type universes}

We introduce a hierarchy of \emph{universes} denoted by primitive constants
$\UU_n$, for each $n=0,1,\ldots$.  They satisfy the following rules.  The first
two say that the universes form a cumulative hierarchy of types, and the third expresses
the idea that an object of a universe can serve as a type and stand to the
right of a colon in judgments:
%
\begin{itemize}
\item $\UU_m : \UU_n$ for $m < n$,
\item if $A:\UU_m$ and $m \le n$, then $A:\UU_n$,
\item if $\Gamma \vdash A : \UU_n$, and $x$ is a new variable, then $\vdash (\Gamma, x:A)\; \ctx$.
\end{itemize}
%
In the body of the book, an equality judgment $A \jdeq B : \UU_n$ between types
$A$ and $B$ is usually abbreviated to $A \jdeq B$.  This is an instance of
typical ambiguity, and the choice of $n$ doesn't affect the validity of the judgment.

The following conversion rule allows us to replace a type by one equal to it in a typing judgment:
%
\begin{itemize}
\item if $a:A$ and $A \jdeq B$ then $a:B$
\end{itemize}

\subsection{Dependent function types (\texorpdfstring{$\Pi$}{Π}-types)}

We introduce a primitive constant $c_\Pi$.  An expression of the form
$c_\Pi(A,\lam{x} B)$ will be written as $\tprd{x:A}B$.  Judgments concerning
such expressions and expressions of the form $\lam{x} b$ are introduced by the following rules:
%
\begin{itemize}
\item if $\Gamma \vdash A:\UU_n$ and $\Gamma,x:A \vdash B:\UU_n$, then $\Gamma \vdash \tprd{x:A}B : \UU_n$
\item if $\Gamma, x:A \vdash b:B$ then $\Gamma \vdash (\lam{x} b) : (\tprd{x:A} B)$
\item if $\Gamma\vdash g:\tprd{x:A} B$ and $\Gamma\vdash t:A$ then $\Gamma\vdash g(t):B[t/x]$
\end{itemize}
%
If $x$ does not occur freely in $B$, we abbreviate $\tprd{x:A} B$ as the non-dependent function type 
$A\rightarrow B$ and derive the following rule:
%
\begin{itemize}
\item if $\Gamma\vdash g:A \rightarrow B$ and $\Gamma\vdash t:A$ then $\Gamma\vdash g(t):B$
\end{itemize}
Using non-dependent function types and leaving implicit the context $\Gamma$, the rules above can be written in the following alternative style that we will continue to use in the rest of this section of the appendix.
%
\begin{itemize}
\item if $A:\UU_n$ and $B:A\to\UU_n$, then $\tprd{x:A}B(x) : \UU_n$
\item if $x:A \vdash b:B$ then $ \lam{x} b : \tprd{x:A} B(x)$
\item if $g:\tprd{x:A} B(x)$ and $t:A$ then $g(t):B(t)$
\end{itemize}
%

\subsection{Dependent pair types (\texorpdfstring{$\Sigma$}{Σ}-types)}

We introduce primitive constants $c_\Sigma$ and $c_{\mathsf{pair}}$.  An
expression of the form $c_\Sigma(A,\lam{a} B)$ will be written as $\sm{a:A}B$,
and an expression of the form $c_{\mathsf{pair}}(a,b)$ will be written as $\tup
a b$.  We write $A\times B$ instead of $\sm{x:A} B$ if $x$ is not free in $B$.

Judgments concerning such expressions are introduced by the following
rules:
%
\begin{itemize}
\item if $A:\UU_n$ and $B: A \rightarrow \UU_n$, then $\sm{x:A}B(x) : \UU_n$
\item if, in addition, $a:A$ and $b:B(a)$, then $\tup a b:\sm{x:A}B(x)$
\end{itemize}
%
If we have $A$ and $B$ as above, $C : \sm{x:A}B(x) \rightarrow \UU_m$, and
\[
  d:\tprd{x:A}{y:B(x)} C(\tup x y)
\]
we can introduce a defined constant 
\[
  f:\tprd{p:\sm{x:A}B(x)} C(p)
\]
with the defining equation
\[
  f(\tup x y)\defeq d(x,y).
\]

$C,d,x,y$ may contain extra implicit parameters $x_1,\ldots,x_n$ if they were obtained in some non-empty context; therefore, the fully explicit recursion schema is
\[ f(x_1,\dots,x_n,\tup{x(x_1,\dots,x_n)}{y(x_1,\dots,x_n)}) \defeq
d(x_1,\dots,x_n,\tup{x(x_1,\dots,x_n)}{y(x_1,\dots,x_n)}) \]

\subsection{Coproduct types}

We introduce primitive constants $c_+$, $c_\inlsym$, and $c_\inrsym$.
We will write $A+B$ instead of $c_+(A,B)$, $\inl(a)$ instead of
$c_\inlsym(a)$, and $\inr(a)$ instead of $c_\inrsym(a)$:
%
\begin{itemize}
\item if $A,B : \UU_n$ then $A + B : \UU_n$
\item moreover, $\inl: A \rightarrow A+B$ and $\inr: B \rightarrow A+B$
\end{itemize}
%
If we have $A$ and $B$ as above, $C : A+B \rightarrow \UU_m$, 
$d:\tprd{x:A} C(\inl(x))$, and $d':\tprd{y:B} C(\inr(y))$,
then we can introduce a defined constant $f:\tprd{z:A+B}C(z)$ with the defining equations
%
\begin{align*}
  f(\inl(x)) & \defeq d(x) \\
  f(\inr(y)) & \defeq d'(y)
\end{align*}

\subsection{The finite types}

We introduce primitive constants $\ttt$, $\emptyt$, $\unit$, satisfying the following rules:
%
\begin{itemize}
\item $\emptyt : \UU_0$, $\unit : \UU_0$
\item $\ttt:\unit$
\end{itemize}

Given $C : \emptyt \rightarrow \UU_n$ we can introduce a defined constant $f:\tprd{x:\emptyt} C(x)$, with no defining equations.

Given $C : \unit \rightarrow \UU_n$ and $d : C(\ttt)$ we can introduce a defined constant $f:\tprd{x:\unit} C(x)$, with defining equation $f(\ttt) \defeq d$.

\subsection{Natural numbers}

The type of natural numbers is obtained by introducing primitive constants
$\N$, $0$, and $\suc$ with the following rules:
%
\begin{itemize}
  \item $\N : \UU_0$,
  \item $0:\N$,
  \item $\suc:\N\rightarrow \N$.
\end{itemize}
%
Furthermore, we can define functions by primitive recursion.  If we have
$C : \N \rightarrow \UU_k $ we can introduce a defined constant $f:\tprd{x:\N}C(x)$ whenever we have
%
\begin{align*}
  d & : C(0) \\
  e & : \tprd{x:\N}(C(x)\rightarrow C(\suc (x)))
\end{align*}
%
with the defining equations
%
\begin{align*}
  f(0) & \defeq d \\
  f(\suc (x)) & \defeq e(x,f(x))
\end{align*}

\subsection{$W$-types}

For $W$-types we introduce primitive constants $c_\wtypesym$ and $c_\suppsym$.
An expression of the form $c_\wtypesym(A,\lam{x} B)$ will be written as
$\wtype{x:A}B$, and an expression of the form $c_\suppsym(x,u)$ will be written
as $\supp(x,u)$:
%
\begin{itemize}
\item if $A:\UU_n$ and $B: A \rightarrow \UU_n$, then $\wtype{x:A}B(x) : \UU_n$
\item if moreover, $a:A$ and $g:B(a)\rightarrow \wtype{x:A}B(x)$ then $\supp(a,g):\wtype{x:A}B(x)$.
\end{itemize}
% 
Here also we can define functions by total recursion.  If we have $A$ and $B$
as above and $C : \wtype{x:A}B(x) \rightarrow \UU_m$, then we can introduce a defined constant
$f:\tprd{z:\wtype{x:A}B(x)} C(z)$ whenever we have
\[
  d:\tprd{x:A}{u:B(x) \rightarrow \wtype{x:A}B(x)}((\tprd{y:B(x)}C(u(y))) \rightarrow C(\supp(x,u)))
\]
with the defining equation
\[
  f(\supp(x,u)) \defeq d(x,u,f\circ u).
\]

\subsection{Identity types}

We introduce primitive constants $c_\idsym$ and $c_\reflsym$.  We will write
$\id[A] a b$ for $c_\idsym(A,a,b)$ and $\refl a$ for $c_\reflsym(A,a)$, when
$a:A$ is understood:
%
\begin{itemize}
\item If $A : \UU_n$, $a:A$, and $b:A$ then $\id[A] a b : \UU_n$.
\item If $a:A$ then $\refl a :\id[A] a a $.
\end{itemize}
%
Given $a:A$, if $y:A, z:\id[A] a y \vdash C : \UU_m$ and 
$\vdash d:C[a,\refl{a}/y,z]$ then we can introduce a defined constant 
\[
  f:\tprd{y:A}{z:\id[A] a y} C
\]
with defining equation
\[
  f(a,\refl{a})\defeq d.
\]

\section{The second presentation}
\label{sec:syntax-more-formally}

In this section, we define the judgments 
\begin{mathpar}
\wfctx\Gamma
\and
\oftp\Gamma{a}{A}
\and
\jdeqtp\Gamma{a}{a'}{A}
\end{mathpar}
inductively using inference rules. In the ``natural deduction'' notation of this
section, to conclude the judgment below the horizontal line, it is necessary to
prove the judgments above the line. For clarity, each rule has a name displayed
to the right of the horizontal line. 

A \emph{derivation} of a judgment is a tree constructed from these inference
rules, whose final conclusion is the judgment in question. If the derivation has
no unresolved hypotheses, we say it is \emph{closed}, and thus proves the
judgment under no hypotheses. In other words, a derivation is closed if all its
leaves $\ctx\text{-}\textsc{emp}$, as this is the only rule with no hypotheses.
For example, the following is a closed derivation of
$\oftp{\emptyctx}{\lamu{x:\unit} x}{\unit\to\unit}$.
%
\begin{mathpar}
\inferrule*[right=$\Pi$-\intro]
  {\inferrule*[right=$\Vble$]
    {\inferrule*[right=\ctx-\textsc{ext}]
      {\inferrule*[right=$\unit$-\form]
        {\inferrule*[right=\ctx-\textsc{emp}]
          {\ }
          {\wfctx {\emptyctx}}}
        {\oftp{}{\unit}{\UU_0}}}
      {\wfctx {\tmtp x\unit}}}
   {\oftp{\tmtp x\unit}{x}{\unit}}}
 {\oftp{\emptyctx}{\lamu{x:\unit} x}{\unit\to\unit}}
\end{mathpar}

\subsection{Contexts}

A context is a list of assumptions of the form $x_i:A_i$. The empty list is a
valid context; given a valid context $\Gamma$, and a valid type $A$ in that context,
$\Gamma$ can be extended with an assumption of type $A$.

\begin{mathpar}
  \inferrule*[right=\ctx-\textsc{emp}]
  {\ }
  {\wfctx\emptyctx}
\and
  \inferrule*[right=\ctx-\textsc{ext}]
  {\oftp\Gamma{A}{\UU_i}}
  {\wfctx{(\Gamma,\tmtp xA)}}
\end{mathpar}

\subsection{Structural rules}

Each assumption in the context can be concluded.

\begin{mathpar}
  \inferrule*[right=$\Vble$]
  {\wfctx {\Gamma,\tmtp xA,\Delta} }
  {\oftp{\Gamma,\tmtp xA,\Delta}{x}{A}}
\end{mathpar}

The following important principles, called \define{substitution} and
\define{weakening}, need not be explicitly assumed. Rather, it is possible to
show, by induction on the structure of all possible derivations, that whenever
the hypotheses of these rules are provable, their conclusion is also
provable.\footnote{Such rules are called \define{admissible}.} ($\mathcal{J}$ is
any judgment $a:A$ or $a\equiv b:A$.)

\begin{mathpar}
  \inferrule*[right=$\Subst$]
  {\oftp\Gamma{a}{A} \\ \judg{\Gamma,\tmtp xA,\Delta}{\mathcal{J}}}
  {\judg{\Gamma,\Delta[a/x]}{\mathcal{J}[a/x]}}
\and
  \inferrule*[right=$\Weak$]
  {\oftp\Gamma{A}{\UU_i} \\ \judg{\Gamma,\Delta}{\mathcal{J}}}
  {\judg{\Gamma,\tmtp xA,\Delta}{\mathcal{J}}}
\end{mathpar}

In addition to the judgmental equality rules given for each type former, we also
assume that judgmental equality is an equivalence relation respected by typing.
\begin{mathparpagebreakable}
  \inferrule*{\oftp\Gamma{a}{A}}{\jdeqtp\Gamma{a}{a}{A}}
\and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A}}{\jdeqtp\Gamma{b}{a}{A}}
\and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A} \\ \jdeqtp\Gamma{b}{c}{A}}{\jdeqtp\Gamma{a}{c}{A}}
\and
  \inferrule*{\oftp\Gamma{a}{A} \\ \jdeqtp\Gamma{A}{B}{\UU_i}}{\oftp\Gamma{a}{B}}
\and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A} \\ \jdeqtp\Gamma{A}{B}{\UU_i}}{\jdeqtp\Gamma{a}{b}{B}}
\end{mathparpagebreakable}

Additionally, for all the type formers below, we assume rules stating that each constructor preserves definitional equality in each of its arguments; for instance, along with the $\Pi$-\intro\ rule, we assume the rule
\[
  \inferrule*[right=$\Pi$-\intro-eq]
  {\jdeqtp\Gamma{A}{A'}{\UU_i} \\
   \jdeqtp{\Gamma,\tmtp xA}{B}{B'}{\UU_i} \\
   \jdeqtp{\Gamma,\tmtp xA}{b}{b'}{B}}
  {\jdeqtp\Gamma{\lamu{x:A} b}{\lamu{x:A'} b'}{\tprd{x:A} B}}
\]
However, we omit these rules for brevity.

\subsection{Type universes}

We have an infinite hierarchy of type universes $\UU_i$ for each natural number
$i$; each universe is contained in the next, and any type in $\UU_i$ is also in
$\UU_{i+1}$.

\begin{mathpar}
\inferrule*[right=\UU-\textsc{intro}]
  {\wfctx \Gamma }
  {\oftp\Gamma{\UU_i}{\UU_{i+1}}}
\and
\inferrule*[right=\UU-\textsc{cumul}]
  {\oftp\Gamma{A}{\UU_i}}
  {\oftp\Gamma{A}{\UU_{i+1}}}
\end{mathpar}

The rules of type theory maintain the invariants that if $\oftp\Gamma{a}{A}$,
then $\oftp\Gamma{A}{\UU_i}$ for some $i$, and if $\jdeqtp\Gamma{a}{b}{A}$,
then $\oftp\Gamma{a}{A}$ and $\oftp\Gamma{b}{A}$.

\subsection{Dependent function types (\texorpdfstring{$\Pi$}{Π}-types)}
\label{sec:more-formal-pi}

In \autoref{sec:function-types}, we introduced non-dependent functions $A\to B$ in
order to define a family of types as a function $\lam{x:A} B:A\to\UU_i$, which
gives rise to a dependent function $\tprd{x:A} B$. Contexts allow us to speak
directly about the types of terms with free variables, so we can instead express
a family of types simply as a type $B$ with a free variable $x:A$, i.e.,
$\oftp{\tmtp xA}{B}{\UU_i}$. As a consequence, we don't need non-dependent
functions to define dependent functions. In fact, the rules for each type former
will not refer to any other type former.

Each type former from here on has a uniform set of rules:
\begin{itemize}
\item a \emph{formation} rule, stating when the type former can be applied;
\item some \emph{introduction} rules, stating how to inhabit the type;
\item an \emph{elimination} rule, or induction principle, stating how to use an
element of the type;
\item some \emph{computation} rules, corresponding to the introduction rules,
giving a judgmental equality for when the elimination rule is applied to an
introductory form.
\end{itemize}

\begin{mathparpagebreakable}
  \def\premise{\oftp{\Gamma}{A}{\UU_i} \and \oftp{\Gamma,\tmtp xA}{B}{\UU_i}}
  \inferrule*[right=$\Pi$-\form]
    \premise
    {\oftp\Gamma{\tprd{x:A}B}{\UU_i}}
\and
  \inferrule*[right=$\Pi$-\intro]
  {\oftp{\Gamma,\tmtp xA}{b}{B}}
  {\oftp\Gamma{\lam{x:A} b}{\tprd{x:A} B}}
\and
  \inferrule*[right=$\Pi$-\elim]
  {\oftp\Gamma{f}{\tprd{x:A} B} \\ \oftp\Gamma{a}{A}}
  {\oftp\Gamma{f(a)}{B[a/x]}}
\and
  \inferrule*[right=$\Pi$-\comp]
  {\oftp{\Gamma,\tmtp xA}{b}{B} \\ \oftp\Gamma{a}{A}}
  {\jdeqtp\Gamma{(\lam{x:A} b)(a)}{b[a/x]}{B[a/x]}}
\end{mathparpagebreakable}

The expression $\lam{x:A} b$ binds free occurrences of $x$ in $b$, as does $\tprd{x:A} B$ for
$B$.

When $B$ does not contain free occurrences of $x$, we obtain as a special case
the ordinary function type $A\to B \defeq \tprd{x:A} B$. Because we did not use
$\to$ to define $\prdsym$, we can simply take this as the \emph{definition} of
$\to$.

We may abbreviate an expression $\lam{x:A} b$ as $\lamu{x:A} b$, with the understanding
that the omitted type $A$ should be filled in appropriately before typechecking.

\subsection{Dependent pair types (\texorpdfstring{$\Sigma$}{Σ}-types)}
\label{sec:more-formal-sigma}

In \autoref{sec:sigma-types}, we needed $\to$ and $\prdsym$ types in order to
define the introduction and elimination rules for $\smsym$; as in the previous
section, we can instead use the context to express dependency without involving
other type formers.

\begin{mathparpagebreakable}
  \def\premise{\oftp{\Gamma}{A}{\UU_i} \and \oftp{\Gamma,\tmtp xA}{B}{\UU_i}}
  \inferrule*[right=$\Sigma$-\form]
    \premise
    {\oftp\Gamma{\tsm{x:A} B}{\UU_i}}
  \and
  \inferrule*[right=$\Sigma$-\intro]
    {\oftp{\Gamma, \tmtp x A}{B}{\UU_i} \\\\
     \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{B[a/x]}}
    {\oftp\Gamma{\tup ab}{\tsm{x:A} B}}
  \and
  \inferrule*[right=$\Sigma$-\elim]
    {\oftp{\Gamma, \tmtp z {\tsm{x:A} B}}{C}{\UU_i} \\
     \oftp{\Gamma,\tmtp x A,\tmtp y B}{g}{C[\tup x y/z]} \\\\
     \oftp\Gamma{p}{\tsm{x:A} B}}
    {\oftp\Gamma{\ind{\tsm{x:A} B}(z.C,x.y.g,p)}{C[p/z]}}
  \and
  \inferrule*[right=$\Sigma$-\comp]
    {\oftp{\Gamma, \tmtp z {\tsm{x:A} B}}{C}{\UU_i} \\
     \oftp{\Gamma, \tmtp x A, \tmtp y B}{g}{C[\tup x y/z]} \\\\
     \oftp\Gamma{a'}{A} \\ \oftp\Gamma{b'}{B[a'/x]}}
    {\jdeqtp\Gamma{\ind{\tsm{x:A} B}(y.C,x.y.g,\tup{a'}{b'})}{g[a',b'/x,y]}{C[\tup {a'} {b'}/z]}}
\end{mathparpagebreakable}

The expression $\tsm{x:A} B$ binds free occurrences of $x$ in $B$. Furthermore, because
$\ind{\tsm{x:A} B}$ has some arguments with free variables beyond those in $\Gamma$,
we bind (following the variable names above) $y$ in $C$, and $a$ and $b$ in $g$.
These bindings are written as $y.C$ and $x.y.g$, to indicate the names of the bound
variables, as discussed in \autoref{formal-intro}. In particular, we treat $\ind{\tsm{x:A} B}$ as a primitive,
two of whose arguments contain binders; this is superficially similar to, but
different from, $\ind{\tsm{x:A} B}$ being a function that takes functions as
arguments.

When $B$ does not contain free occurrences of $x$, we obtain as a special case
the cartesian product $A \times B \defeq \tsm{x:A} B$. (Again, we can take this
as the \emph{definition} of the cartesian product.)

\subsection{Coproduct types}

\begin{mathparpagebreakable}
  \inferrule*[right=$+$-\form]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i}}
  {\oftp\Gamma{A+B}{\UU_i}}
\\\\
  \inferrule*[right=$+$-\intro${}_1$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i} \\\\ \oftp\Gamma{a}{A}}
  {\oftp\Gamma{\inl(a)}{A+B}}
\and
  \inferrule*[right=$+$-\intro${}_2$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i} \\\\ \oftp\Gamma{b}{B}}
  {\oftp\Gamma{\inr(b)}{A+B}}
\\\\
  \inferrule*[right=$+$-\elim]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\\\
   \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
   \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
   \oftp\Gamma{e}{A+B}}
  {\oftp\Gamma{\ind{A+B}(z.C,x.c,y.d,e)}{C[e/z]}}
\and
  \inferrule*[right=$+$-\comp${}_1$]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
   \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
   \oftp\Gamma{a}{A}}
  {\jdeqtp\Gamma{\ind{A+B}(z.C,x.c,y.d,\inl(a))}{c[a/x]}{C[\inl(a)/z]}}
\and
  \inferrule*[right=$+$-\comp${}_2$]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
   \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
   \oftp\Gamma{b}{B}}
  {\jdeqtp\Gamma{\ind{A+B}(z.C,x.c,y.d,\inr(b))}{d[b/y]}{C[\inr(b)/z]}}
\end{mathparpagebreakable}

In $\ind{A+B}$, $z$ is bound in $C$, $x$ is bound in $c$, and $y$ is bound in
$d$.

\subsection{The empty type $\emptyt$}

\begin{mathparpagebreakable}
  \inferrule*[right=$\emptyt$-\form]
  {\wfctx\Gamma}
  {\oftp\Gamma\emptyt{\UU_i}}
\and
  \inferrule*[right=$\emptyt$-\elim]
  {\oftp{\Gamma,\tmtp x\emptyt}{C}{\UU_i} \\ \oftp\Gamma{a}{\emptyt}}
  {\oftp\Gamma{\ind{\emptyt}(x.C,a)}{C[a/x]}}
\end{mathparpagebreakable}

In $\ind{\emptyt}$, $x$ is bound in $C$.  The empty type comes with no introduction rule and no computation rule.

\subsection{The unit type $\unit$}

\begin{mathparpagebreakable}
  \inferrule*[right=$\unit$-\form]
  {\wfctx\Gamma}
  {\oftp\Gamma\unit{\UU_i}}
\and
  \inferrule*[right=$\unit$-\intro]
  {\wfctx\Gamma}
  {\oftp\Gamma{\ttt}{\unit}}
\and
  \inferrule*[right=$\unit$-\elim]
  {\oftp{\Gamma,\tmtp x\unit}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp y\unit}{c}{C[y/x]} \\
   \oftp\Gamma{a}{\unit}}
  {\oftp\Gamma{\ind{\unit}(x.C,y.c,a)}{C[a/x]}}
\and
  \inferrule*[right=$\unit$-\comp]
  {\oftp{\Gamma,\tmtp x\unit}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp y\unit}{c}{C[y/x]}}
  {\jdeqtp\Gamma{\ind{\unit}(x.C,y.c,\ttt)}{c[\ttt/y]}{C[\ttt/x]}}
\end{mathparpagebreakable}

In $\ind{\unit}$, $x$ is bound in $C$, and $y$ is bound in $c$.

\subsection{The natural number type}

We give the rules for natural numbers, following \autoref{sec:inductive-types}.

\begin{mathparpagebreakable}
  \def\premise{
     \oftp{\Gamma,\tmtp x{\N}}{C}{\UU_i} \\
     \oftp\Gamma{c_0}{C[0/x]} \\
     \oftp{\Gamma,\tmtp{x}\N,\tmtp y C}{c_s}{C[\suc(x)/x]}}
  \inferrule*[right=$\N$-\form]
  {\wfctx\Gamma}
  {\oftp\Gamma{\N}{\UU_i}}
\and
  \inferrule*[right=$\N$-\intro${}_1$]
  {\wfctx\Gamma}
  {\oftp\Gamma{0}{\N}}
\and
  \inferrule*[right=$\N$-\intro${}_2$]
  {\oftp\Gamma{n}{\N}}
  {\oftp\Gamma{\suc(n)}{\N}}
\and
  \inferrule*[right=$\N$-\elim]
  {\premise \\\\ \oftp\Gamma{n}{\N}}
  {\oftp\Gamma{\ind{\N}(x.C,c_0,x.y.c_s,n)}{C[n/x]}}
\and
  \inferrule*[right=$\N$-\comp${}_1$]
  {\premise}
  {\jdeqtp\Gamma{\ind{\N}(x.C,c_0,x.y.c_s,0)}{c_0}{C[0/x]}}
\and
  \inferrule*[right=$\N$-\comp${}_2$]
  {\premise \\\\ \oftp\Gamma{n}{\N}}
  {\Gamma\vdash \ind{\N}(x.C,c_0,x.y.c_s,\suc(n))
   \hspace{2.3cm}\\ \hspace{2.3cm}\equiv
   c_s[n,\ind{\N}(x.C,c_0,x.y.c_s,n)/x,y] : C[\suc(n)/x]}
\end{mathparpagebreakable}

In $\ind{\N}$, $x$ is bound in $C$, and $x$ and $y$ are bound in $c_s$.

Other inductively defined types follow the same general scheme.

\subsection{Identity types}

This presentation corresponds to the Martin-L\"{o}f rule in
\autoref{sec:identity-types}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\idsym$-\form]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{A}}
  {\oftp\Gamma{\id[A]{a}{b}}{\UU_i}}
\and
  \inferrule*[right=$\idsym$-\intro]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{a}{A}}
  {\oftp\Gamma{\refl a}{\id[A]aa}}
\and
  \inferrule*[right=$\idsym$-\elim]
  {\oftp{\Gamma,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
   \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{A} \\ \oftp\Gamma{p'}{\id[A]ab}}
  {\oftp\Gamma{\ind{\idsym_A}(x.y.p.C,z.c,a,b,p')}{C[a,b,p'/x,y,p]}}
\and
  \inferrule*[right=$\idsym$-\comp]
  {\oftp{\Gamma,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
   \oftp\Gamma{a}{A}}
  {\jdeqtp\Gamma{\ind{\idsym_A}(x.y.p.C,z.c,a,a,\refl a)}{c[a/z]}{C[a,a,\refl a/x,y,p]}}
\end{mathparpagebreakable}

In $\ind{\idsym_A}$, $x$, $y$, and $p$ are bound in $C$, and $z$ is bound in
$c$.

\subsection{The \texorpdfstring{$\eta$}{η}-conversion rule}

We introduce the $\eta$-conversion rule for functions; see
\autoref{sec:function-types}; it introduces a judgmental equality.

\begin{mathparpagebreakable}
  \inferrule*[right=$\Pi$-$\eta$]
  {\oftp\Gamma{f}{\tprd{x:A} B}}
  {\jdeqtp\Gamma{f}{(\lamu{x:A}f(x))}{\tprd{x:A} B}}
\end{mathparpagebreakable}

Various theorems in the text of the book, such as \autoref{thm:eta-sigma}, are
referred to as $\eta$-equivalence rules, but these are derivable propositional
equalities, and so need not be asserted as part of the type theory.

\subsection{Definitions}

Although this section's formalism allows us to construct functions out of
inductive types without defining new constants, we would still like to define
named constants, such as $\isequiv$, as a matter of convenience.  Informally, we can
think of these constants as abbreviations of their definitions, but the
situation is a bit more subtle than this. 

For example, consider function composition, which we say takes $f:A\to B$ and
$g:B\to C$ to $g\circ f:A\to C$. But for $\circ$ to work for any such $f,g$, we
must abstract not only over the functions $f,g$ but also the types $A,B,C$:
\[ \circ \defeq \lam{A:\UU_i}{B:\UU_i}{C:\UU_i}{g:B\to C}{f:A\to B}{x:A} g(f(x)) \]
On the other hand, we don't want to annotate each application of $\circ$ with
applications to $A,B,C$. Thus, $\circ$ does not, strictly speaking, stand for
its precise definition; its suppressed arguments, which can be inferred from
$f,g$, are called \define{implicit arguments}.

Implicit argument inference, typical ambiguity (\autoref{sec:universes}),
ensuring that symbols are only defined once, etc., are collectively called
\define{elaboration}. Elaboration must take place prior to typechecking, and is
thus not usually presented as part of the core type theory. However, it is
essentially impossible to use any implementation of type theory which does not
perform robust elaboration.

\section{Axioms for homotopy type theory}

There are two basic ways of introducing axioms such as function extensionality,
univalence, or any other axiom which does not introduce new syntax or new
judgmental equalities---we could either add a primitive constant to the theory
which inhabits the axiom, or we could simply prove all theorems in a context
hypothesizing the presence of a variable that inhabits the axiom, as proposed in \autoref{sec:axioms}.

While these are essentially equivalent, we choose the former approach because we
consider these axioms of homotopy type theory to be part of the core theory,
always present. (While this section is written in the style of
\autoref{sec:syntax-more-formally}, our approach is equally suited to the
presentation in \autoref{sec:syntax-informally}.)

We begin by recalling some auxiliary definitions.

In \autoref{lem:map}, we defined the functorial action of $f:A\to B$ on a path
$p:\id[A] xy$ as
\[
\apfunc f(p) \defeq \ind{\idsym_A} (x.y.p.\id[B] {f(x)} {f(y)}, \lamu{x:A} \refl {f(x)}, x,y,p )
\]
%
In \autoref{ex:composition}, we defined the composition of $g:B\to C$ after
$f:A\to B$ as
\[ g \circ f \defeq \lamu{x:A} g(f(x)) \]
%
In \autoref{defn:homotopy}, we said $f,f':A\to B$ are homotopic ($f\htpy f'$) if
\[ \prd{x:A} \id[B] {f(x)} {g(x)} \]
%
In \autoref{defn:ishae}, we said $f:A\to B$ is a half-adjoint equivalence
($\ishae(f)$) when
\[
\sm{g:B\to A}{\eta: g \circ f \htpy \idfunc[A]}{\epsilon:f \circ g \htpy \idfunc[B]} \prd{x:A} \apfunc{f}{(\eta x)} = \epsilon(fx)
\]
%
As in \autoref{sec:concluding-remarks}, we define $\isequiv(f) \defeq
\ishae(f)$, and we say simply that $f$ is an equivalence. We write $\eqv AB$
for the type of equivalences $\sm{f:A\to B} \isequiv(f)$.

In \eqref{eq:happly}, we defined $\happly_{f,g} : (\id fg)\to (f\htpy g)$ by
\[
\happly_{f,g}(p) \defeq
  \ind{\idsym_{\tprd{x:A} B}} (
    f.g.p. {\prd{x:A} \id[B(x)]{f(x)}{g(x)}},
    h. \lamu{x:A} \refl {h(x)},
    f,g,p).
\]

Finally, we assert the axiom of function extensionality (\autoref{axiom:funext})
by introducing a new constant, $\funext$, which asserts that for each
$f,g$, $\happly_{f,g}$ is an equivalence $\eqv{(\id fg)}{(f\htpy g)}$.
\begin{mathparpagebreakable}
  \inferrule*[right=$\Pi$-\textsc{ext}]
  {\oftp\Gamma{f}{\tprd{x:A} B} \\
   \oftp\Gamma{g}{\tprd{x:A} B}}
  {\oftp\Gamma{\funext(f,g)}{\isequiv(\happly_{f,g})}}
\end{mathparpagebreakable}

In \eqref{eq:uidtoeqv}, we defined the conversion from paths $\id[\UU_i] AB$
to equivalences $\eqv AB$ as
\[
\idtoeqv_{A,B} \defeq
\lamu{p:\id[\UU_i] A B}
\ind{\idsym_{\UU_i}}(
      A.B.p.(\eqv A B),
      A.{\tup {\lamu{x:A} x}
              {\tup {\lamu{x:A} x}
                    {\tup {\lamu{x:A} \refl x}
                          {\tup {\lamu{x:A} \refl x}
                                {\lamu{x:A} \refl {\refl x}}}}}},
      A,B,p).
\]

We assert the univalence axiom (\autoref{axiom:univalence}), by introducing a new
constant, $\ua$, which asserts that for each $A,B$, $\idtoeqv_{A,B}$
is an equivalence $\eqv{(\id[\UU_i] AB)}{(\eqv AB)}$.
\begin{mathparpagebreakable}
  \inferrule*[right=$\UU_i$-\textsc{univ}]
  {\oftp\Gamma{A}{\UU_i} \\
   \oftp\Gamma{B}{\UU_i}}
  {\oftp\Gamma{\ua(A,B)}{\isequiv(\idtoeqv_{A,B})}}
\end{mathparpagebreakable}

\subsection{The circle type}

Here we give an example of a higher inductive type.  Other HITs follow the same
general scheme --- it is beyond the scope of this appendix to cover them all.

Note that the rules below do not precisely follow the pattern of the ordinary
inductive types above: the rules refer to the notions of transport and
functoriality of maps (\autoref{sec:functors}), and the second computation rule
is a propositional, not judgmental, equality. These differences are discussed
in \autoref{sec:dependent-paths}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\Sn^1$-\form]
  {\wfctx\Gamma}
  {\oftp\Gamma{\Sn^1}{\UU_i}}
\and
  \inferrule*[right=$\Sn^1$-\intro${}_1$]
  {\wfctx\Gamma}
  {\oftp\Gamma{\base}{\Sn^1}}
\and
  \inferrule*[right=$\Sn^1$-\intro${}_2$]
  {\wfctx\Gamma}
  {\oftp\Gamma{\lloop}{\id[\Sn^1]{\base}{\base}}}
\and
  \inferrule*[right=$\Sn^1$-\elim]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b} \\
   \oftp\Gamma{p}{\Sn^1}}
  {\oftp\Gamma{\ind{\Sn^1}(x.C,b,\ell,p)}{C[p/x]}}
\and
  \inferrule*[right=$\Sn^1$-\comp${}_1$]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b}}
  {\jdeqtp\Gamma{\ind{\Sn^1}(x.C,b,\ell,\base)}{b}{C[\base/x]}}
\and
  \inferrule*[right=$\Sn^1$-\comp${}_2$]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b}}
  {\oftp\Gamma{\Sn^1\text{-}\mathsf{loopcomp}}
    {\id {\apd{(\lamu{y:\Sn^1} \ind{\Sn^1}(x.C,b,\ell,y))}{\lloop}} {\ell}}}
\end{mathparpagebreakable}

In $\ind{\Sn^1}$, $x$ is bound in $C$.  The notation ${\dpath C \lloop b b}$ for dependent paths was introduced in \autoref{sec:dependent-paths}.

\section{Algorithmic and semantic properties}

\subsection*{Conversion and reduction}

%Together with t
The $\beta$-conversion defining equation for lambda abstraction
\[
  (\lam{x} t)(u) \defeq t[u/x]
\]
and the defining equations for the defined constants form the
%we have $\defeq$ as 
rewriting rules (unfolding definitions) that determine reduction 
steps for a rewriting 
system which has the confluence (or Church-Rosser) property: we can
define $t \conv u$ to mean that $t$ and $u$ can be reduced to the same term by 
using these rewriting rules.


\subsection*{Some syntactical properties of the type theory}
 This system has the following syntactical properties.

\begin{thm}\label{red}
If $A : \UU$ and $A \conv A'$ then $A' : \UU$.
If $t:A$ and $t \conv t'$ then $t':A$.
\end{thm}

We say that a term is \define{normalizable}, respectively \define{strongly normalizable}, if 
some, respectively every, sequence of reduction steps from the term terminates.

\begin{thm}\label{SN}
 If $A : \UU$ then $A$ is strongly normalizable.
 If $t:A$ then $A$ and $t$ are strongly normalizable.
\end{thm}

We say that a term is in \define{normal form} if it cannot be reduced, and that a 
term is a \define{closed term} if no variable occurs freely in it.  A closed
normal type has to be a primitive type, i.e., to be of the form $c(\vec{v})$
for some primitive constant $c$ (where the list $\vec{v}$ of closed normal terms may be omitted if empty, for
instance, as with $\N$).  More generally we have the following explicit
description of terms in normal form.

\begin{lem}\label{normal}
  The terms in normal form can be described by the following syntax
  % 
  \begin{align*}
    v & \production  k \mid \lam{x} v \mid c(\vec{v}) \mid f(\vec{v}), \\
    k &\production x \mid k(v) \mid f(\vec{v})(k),
  \end{align*}
  % 
  where $f(\vec{v})$ represents a partial application of the defined function $f$.
  In particular, a type in normal form is of the form $k$ or $c(\vec{v})$.
\end{lem}

\begin{thm}
  If $A$ is in normal form then the 
  judgment $A : \UU$ is decidable. If $A : \UU$ and $t$ is in normal form then the judgment
  $t:A$ is decidable.
\end{thm}

A corollary is the \define{consistency} property: there is no proof of $\emptyt$ in the empty
context. Indeed if we have $t:\emptyt$ then by \autoref{red,SN} the term $t$ will reduce
to a term in normal form $t'$ that satisfies $t':\emptyt$, but this is not possible by a 
purely combinatorial argument using \autoref{normal}. Similarly, we have the following
\emph{canonicity} property: if $t:N$ in the empty context, then $t$ has to reduce to a
normal form $\suc^k(0)$ for some numeral $k$. Finally, it means that, if we restrict to terms
in normal form, the typing relation is \emph{decidable}, and identifying type-checking with
\emph{proof-checking}, we can indeed ``recognize a proof of an assertion when we see one''.


\sectionNotes\label{subsec:general-remarks}

% This presentation is strongly inspired by two  Martin-L\"of 1972 and 1973.

The system of rules with introduction (primitive constants) and elimination
and computation rules (defined constant) is inspired by Gentzen natural
deduction. The possibility of strengthening the elimination rule for
existential quantification was indicated in \cite{howard:pat}. The
strengthening of the axioms for disjunction appears in \cite{Martin-Lof-1972},
and for absurdity elimination and identity type in \cite{Martin-Lof-1973}. The
$W$-types were introduced in \cite{Martin-Lof-1979}. They generalize a notion
of trees introduced by \cite{Tait-1968}.
%inspired from unpublished work of Spector.

The generalized form of primitive recursion for natural numbers and ordinals
appear in \cite{Hilbert-1925}.  This motivated G\"odel's system $T$,
\cite{Goedel-T-1958}, which was analyzed by \cite{Tait-1966}, who used,
following \cite{Goedel-1958}, the terminology ``definitional equality'' for
conversion: two terms are \emph{judgmentally equal} if they reduce to a
common term by means of a sequence of applications of the reduction
rules. This terminology was also used by de Bruijn \cite{deBruijn-1973} in his
presentation of \emph{Automath}.

Streicher \cite[Theorem 4.13]{Streicher-1991}, explains how to give the
semantics in contextual category of terms in normal form using a simple syntax
similar to the one we have presented.

Our second presentation comprises fairly standard presentation of
intensional Martin-L\"{o}f type theory, with some additional features needed in
homotopy type theory. Compared to a reference presentation of
\cite{hofmann:syntax-and-semantics}, the type theory of this book has a few
non-critical differences:
%
\begin{itemize}
\item universes \`{a} la Russell, in the sense of
\cite{martin-lof:bibliopolis};
\item judgmental $\eta$ and function extensionality for $\Pi$ types;
\end{itemize}
and a few features essential for homotopy type theory:
\begin{itemize}
\item the univalence axiom;
\item higher inductive types.
\end{itemize}
%
As a matter of convenience, the book primarily defines functions by induction
using definition by \emph{pattern matching}. It is possible to formalize the
notion of pattern matching, as done in \autoref{sec:syntax-informally}. However, the
standard type-theoretic presentation, adopted in this section, is to introduce a single \emph{dependent
eliminator} for each type former, from which functions out of that type must be
defined.\footnote{This approach is easier to formalize both syntactically and
semantically, as it amounts to the universal property of the type former.}
The two approaches are equivalent; see \autoref{sec:pattern-matching} for a
longer discussion.

%It is possible to algorithmically determine the type, if one exists, of a term.
%It is also possible to algorithmically establish equality between terms; an
%algorithm is included in \autoref{sec:syntax-informally}.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 

